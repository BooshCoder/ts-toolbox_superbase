[
  {
    "id": "1",
    "question": "1. Що таке JavaScript?",
    "answer": "Опис JavaScript:\nJavaScript — це динамічна, прототипно-орієнтована мова програмування, яка використовується для створення інтерактивного контенту на вебсторінках. Вона підтримує подієве програмування, асинхронність і працює в браузері, а також на сервері через Node.js.",
    "codeExample": "",
    "category": "dom",
    "isFavorite": false
  },
  {
    "id": "2",
    "question": "2. Які ключові слова використовуються для оголошення змінних у JavaScript?",
    "answer": "У JavaScript змінні можна оголошувати за допомогою трьох ключових слів:\n`var`\nСтарий спосіб оголошення змінних.\nОбласть видимості: функціональна (в межах функції, а не блоку).\nПідтримує підняття (hoisting): змінну можна використовувати до оголошення, але значення буде undefined.\nНе рекомендується через можливість помилок.\n  \n`let`\nВикористовується для змінних, які можуть змінювати значення.\nОбласть видимості: блочна (в межах {}).\nНе дозволяє повторного оголошення в межах однієї області.\nНе піддається підняттю з доступом до значення.\n  ```javascript\n  let y = 20;\n  y = 30; // Можна змінити значення\n  ```\n`const`\nВикористовується для змінних, значення яких не змінюється.\nОбласть видимості: блочна.\nПотрібно обов’язково ініціалізувати при оголошенні.\nЯкщо змінна є об’єктом або масивом, значення властивостей можна змінювати, але саму змінну перевизначити не можна.\n  ```javascript\n  const z = 40;\n  // z = 50; // Помилка\n  ```\n**Рекомендації:**\n  - Використовувати `const` для змінних, які не змінюються.\n  - Використовувати `let` для змінних, які змінюють значення.\n  - `var` уникати, якщо це не потрібно для специфічної підтримки старих браузерів.",
    "codeExample": "var x = 10;",
    "category": "arrays",
    "isFavorite": false
  },
  {
    "id": "3",
    "question": "3. Перерахуйте типи даних у JavaScript.",
    "answer": "Типи даних у JavaScript\n**Примітивні:**\n`string`\n`number`\n`boolean`\n`null`\n`undefined`\n`bigint`\n`symbol`\n**Складні:**\n`object` (включаючи масиви, функції, дати тощо).",
    "codeExample": "",
    "category": "arrays",
    "isFavorite": false
  },
  {
    "id": "4",
    "question": "4. У чому різниця між функціональним (functional) і подієвим (event-driven) програмуванням у JavaScript?",
    "answer": "Різниця між функціональним та подієвим програмуванням у JavaScript\n**Функціональне програмування:**\n  - Базується на чистих функціях, які не мають побічних ефектів.\n  - Дані не змінюються, використовується іммутабельність.\n  - Код пишеться у вигляді композиції функцій (`map`, `reduce`, `filter`).\n  - Наприклад: обробка даних у масиві через функції вищого порядку.\n**Подієве програмування:**\n  - Реакція на події (`click`, `hover`, `async responses`).\n  - Використовує слухачі (`event listeners`) та обробники подій (`callbacks`).\n  - Побудоване на взаємодії з подіями в середовищі (браузері чи Node.js).\n  - Наприклад: виклик функції при кліку на кнопку.",
    "codeExample": "",
    "category": "arrays",
    "isFavorite": false
  },
  {
    "id": "5",
    "question": "5. У якому році відбувся перший реліз JavaScript, і в якому браузері він був вперше використаний?",
    "answer": "Рік першого релізу JavaScript та перший браузер\nПерший реліз JavaScript відбувся в 1995 році. Він був вперше реалізований у браузері Netscape Navigator.",
    "codeExample": "",
    "category": "other",
    "isFavorite": false
  },
  {
    "id": "6",
    "question": "6. Чим відрізняється масив та обʼєкт? У яких випадках що використовуєте?",
    "answer": "Різниця між масивом та обʼєктом і їх використання в JavaScript\n**Масив:**\n  - Використовується для зберігання впорядкованих елементів.\n  - Індексовані значення (0, 1, 2, …).\n  - Підходить для роботи з колекціями даних, де порядок важливий або коли потрібно виконувати операції типу сортування.\n**Обʼєкт:**\n  - Використовується для зберігання пар \"ключ-значення\".\n  - Доступ до значень через ключі (не індекси).\n  - Підходить для зберігання даних з різними властивостями або для створення складних структур.\n**Використання:**\n**Масив:** коли порядок елементів важливий або ви працюєте з колекцією однотипних елементів (наприклад, список користувачів).\n**Обʼєкт:** коли потрібно зберігати дані з різними властивостями або асоціативні пари (наприклад, профіль користувача з різними атрибутами).",
    "codeExample": "",
    "category": "arrays",
    "isFavorite": false
  },
  {
    "id": "7",
    "question": "7. Events в JavaScript. Розкажіть про event propagation, bubbling, delegation, preventing тощо.",
    "answer": "Обробка подій в JavaScript: Propagation, Bubbling, Delegation, Preventing тощо\n**Event Propagation** — це процес, при якому подія, що сталася на елементі, \"поширюється\" через DOM дерево. Є два основні етапи:\n**Bubbling** (Спливання):\n   Подія спочатку викликається на найбільш вкладеному елементі, потім вона спливає до батьківських елементів (від внутрішнього до зовнішнього). Наприклад, якщо клікнути на кнопку всередині контейнера, подія спочатку буде оброблятися кнопкою, потім контейнером, і так далі, поки не досягне кореневого елемента (document).\n**Capturing** (Ловлення):\n   Подія спочатку обробляється на найвищому рівні DOM дерева (наприклад, document), а потім спускається вниз до цільового елемента.\n**Event Delegation** — це техніка обробки подій, коли ви додаєте один обробник подій на батьківський елемент, а не на кожен окремий дочірній елемент. Це дозволяє зменшити кількість обробників і є ефективним способом обробки подій на динамічно створених елементах.\n**Preventing Default Behavior** (Запобігання стандартній поведінці):\n  - Метод event.preventDefault() дозволяє зупинити стандартну поведінку події. Наприклад, можна скасувати перезавантаження сторінки при натисканні на посилання або скасувати відправку форми.\n**stopPropagation() vs. stopImmediatePropagation():**\n  - stopPropagation(): Зупиняє подальше поширення події по DOM, але не скасовує інші обробники подій на поточному елементі.\n  - stopImmediatePropagation(): Зупиняє подальше поширення події і скасовує інші обробники подій, що могли бути зареєстровані на тому самому елементі.",
    "codeExample": "",
    "category": "dom",
    "isFavorite": false
  },
  {
    "id": "8",
    "question": "8. Чи можливо перевизначити const?",
    "answer": "Перевизначення значення `const`\nНі, значення, оголошене через const, не можна змінити. Це означає, що ви не можете переназначити змінну, оголошену з const, на нове значення. Однак, якщо const використовується для оголошення обʼєкта або масиву, ви все ще можете змінювати його вміст (наприклад, додавати властивості до обʼєкта або елементи до масиву). Тобто, const гарантує, що сама змінна не може бути переназначена, але не захищає від змін всередині складних типів даних (масивів, обʼєктів).",
    "codeExample": "",
    "category": "arrays",
    "isFavorite": false
  },
  {
    "id": "9",
    "question": "9. Чи відомі вам принципи DRY, KISS, YAGNI, SOLID?",
    "answer": "Принципи DRY, KISS, YAGNI, SOLID\nТак, ці принципи широко використовуються в програмуванні для забезпечення чистого, підтримуваного і ефективного коду.\n**DRY (Don't Repeat Yourself)** — уникайте дублювання коду. Якщо одна й та сама логіка зустрічається в кількох місцях, варто створити спільну функцію або метод, щоб зробити код більш зручним для підтримки.\n**KISS (Keep It Simple, Stupid)** — підтримуйте код простим і зрозумілим. Уникайте надмірної складності і зайвих абстракцій. Простота покращує підтримуваність і знижує ймовірність помилок.\n**YAGNI (You Aren't Gonna Need It)** — не додавайте функціональність, яку наразі не потрібно. Створювати код тільки для майбутніх можливостей може призвести до зайвих витрат часу і складності.\n**SOLID** — набір принципів для об'єктно-орієнтованого програмування, що допомагають створювати гнучкий, зрозумілий і підтримуваний код:\nS (Single Responsibility Principle) — кожен клас чи функція має виконувати одну задачу.\nO (Open/Closed Principle) — код має бути відкритим для розширення, але закритим для модифікації.\nL (Liskov Substitution Principle) — обʼєкти підкласів повинні заміняти обʼєкти батьківських класів без порушення роботи програми.\nI (Interface Segregation Principle) — не змушуйте класи реалізовувати інтерфейси, які вони не використовують.\nD (Dependency Inversion Principle) — залежності повинні бути від абстракцій, а не від конкретних класів.",
    "codeExample": "",
    "category": "objects",
    "isFavorite": false
  },
  {
    "id": "10",
    "question": "10. У чому відмінності LocalStorage від SessionStorage?",
    "answer": "Відмінності між LocalStorage та SessionStorage\n**LocalStorage:**\n  - Зберігає дані без обмежень по часу, дані зберігаються навіть після закриття браузера або вкладки.\n  - Доступні для всіх вкладок і вікон того ж самого домену.\n  - Обмеження на обсяг — зазвичай 5-10 МБ на домен.\n  - Дані зберігаються, поки вони не будуть явно видалені.\n**SessionStorage:**\n  - Дані зберігаються тільки в межах однієї сесії (до закриття вкладки або вікна браузера).\n  - Доступні тільки в тій самій вкладці або вікні, в якій були збережені.\n  - Обсяг схожий на LocalStorage (5-10 МБ).\n  - Дані видаляються автоматично при закритті вкладки або браузера.\n**Основні відмінності:**\n  - **Тривалість зберігання:** LocalStorage — дані зберігаються постійно, SessionStorage — тільки на час сесії.\n  - **Доступність:** LocalStorage доступний для всіх вкладок, SessionStorage — тільки для поточної вкладки.",
    "codeExample": "",
    "category": "dom",
    "isFavorite": false
  },
  {
    "id": "11",
    "question": "11. Що таке замикання (closure) в JavaScript і як воно працює?",
    "answer": "Замикання (closure) в JavaScript та його принцип роботи.\n**Замикання (closure)** — це функція, яка \"запам'ятовує\" оточення, в якому була створена. Це дозволяє функції доступ до змінних, навіть після того, як зовнішня функція, в якій вона була оголошена, завершила своє виконання.\n**Як це працює:**\n  - **Оточення:** Кожна функція в JavaScript має доступ до змінних, які знаходяться в її власному оточенні (локальні змінні), а також до змінних, які були доступні в оточенні, де функція була створена.\n  - **Замикання:** Коли функція всередині іншої функції повертається або передається, вона все ще має доступ до змінних оточення, навіть якщо зовнішня функція вже завершила виконання.\n**Приклад:**",
    "codeExample": "function outer() {\n    let counter = 0; // локальна змінна зовнішньої функції\n\n    return function inner() {\n      // внутрішня функція\n      counter++; // доступ до змінної outer()\n      console.log(counter);\n    };\n  }\n\n  const increment = outer(); // викликаємо outer, що повертає функцію inner\n  increment(); // виведе 1\n  increment(); // виведе 2",
    "category": "functions",
    "isFavorite": false
  },
  {
    "id": "12",
    "question": "12. Що таке Кукі (cookies) і як вони працюють в JavaScript?",
    "answer": "Кукі (cookies) в JavaScript: як вони працюють і для чого використовуються.\nКукі (cookies) — це невеликі фрагменти даних, які вебсайт зберігає в браузері користувача. Вони використовуються для зберігання інформації, яка може бути використана для ідентифікації користувача, збереження налаштувань, відслідковування сесій тощо.\n**Як працюють кукі в JavaScript:**\n**Зчитування кукі:** Веб-браузер автоматично додає всі кукі для поточного домену до заголовка запиту, і JavaScript може отримати їх через document.cookie.\n    \n**Запис кукі:** Кукі встановлюються за допомогою властивості document.cookie. Формат для встановлення кукі виглядає так:\n    ```javascript\n    document.cookie =\n      \"name=value; expires=Thu, 31 Dec 2025 23:59:59 UTC; path=/\";\n    ```\n    - У цьому прикладі:\n      - \"name=value\" — це ключ-значення кукі.\n      - expires — вказує дату, коли кукі стане неактивним. Якщо не вказано, кукі буде тимчасовим і видалиться після закриття браузера.\n      - path — визначає, до якого шляху на сайті доступна кукі.\n**Видалення кукі:** Щоб видалити кукі, потрібно встановити її термін придатності в минуле:\n    ```javascript\n    document.cookie = \"name=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/\";\n    ```\n**Особливості:**\n  - Термін дії: Кукі можуть бути тимчасовими або мати встановлений термін дії.\n  - Обмеження на розмір: Кожна кукі може зберігати до 4 КБ даних, і браузер зберігає до 20 кукі на домен.\n  - Обмеження на доступність: Кукі можуть бути доступні лише на тому домені і підкаталозі, де вони були встановлені.\n  - Безпека: Кукі можуть бути позначені як Secure (щоб передавались лише через HTTPS) і HttpOnly (щоб вони не були доступні через JavaScript).\n**Використання кукі:**\n  - Ідентифікація користувача (наприклад, для збереження сесій).\n  - Збереження налаштувань користувача (темна/світла тема, мова сайту).\n  - Відслідковування статистики (аналітика).\n  - Кукі є важливим інструментом для взаємодії між клієнтом і сервером, але їх потрібно використовувати обережно через питання конфіденційності та безпеки.",
    "codeExample": "const cookies = document.cookie;\n    console.log(cookies); // виведе всі кукі у вигляді рядка",
    "category": "objects",
    "isFavorite": false
  },
  {
    "id": "13",
    "question": "13. Що таке область видимості змінної?",
    "answer": "Область видимості змінної в JavaScript.\n**Область видимості змінної** — це частина коду, в межах якої до змінної можна отримати доступ. У JavaScript існують три основні типи області видимості:\n**Глобальна область видимості (Global Scope):**\nЗмінна доступна у всьому коді.\nЗмінні, оголошені поза будь-якими функціями або блоками, автоматично стають глобальними.\nГлобальні змінні створюються з використанням ключових слів var, let, const, або без них (хоча останнє — погана практика).\n  \n**Функціональна область видимості (Function Scope):**\nЗмінні, оголошені всередині функції з використанням var, доступні лише в межах цієї функції.\nЦя область видимості застосовується лише до var. Змінні let і const підкоряються блочній області видимості.\n  ```javascript\n  function test() {\n    var localVar = \"I am local\";\n    console.log(localVar); // доступна всередині функції\n  }\n  test();\n  console.log(localVar); // помилка: localVar не визначена\n  ```\n**Блочна область видимості (Block Scope):**\nЗмінні, оголошені з використанням let або const, доступні тільки всередині блоку {}.\nНе застосовується до змінних, оголошених через var.\n  ```javascript\n  {\n    let blockVar = \"I am block scoped\";\n    const blockConst = \"I am also block scoped\";\n    console.log(blockVar); // доступна\n  }\n  console.log(blockVar); // помилка: blockVar не визначена\n  ```\n**Вкладені області видимості:**\n  - Внутрішня область може отримати доступ до змінних з зовнішньої області, але не навпаки.\n  ```javascript\n  function outer() {\n    let outerVar = \"outer\";\n    function inner() {\n      console.log(outerVar); // доступ до змінної зовнішньої функції\n    }\n    inner();\n  }\n  outer();\n  ```\n**Hoisting (Підняття):**\n  - У JavaScript змінні, оголошені через var, \"піднімаються\" на початок своєї області видимості, але без ініціалізації.\n  - Змінні, оголошені через let і const, також піднімаються, але недоступні до моменту їхньої ініціалізації (це називається \"Temporal Dead Zone\").\n  ```javascript\n  console.log(a); // undefined\n  var a = 10;\n  console.log(b); // помилка\n  let b = 20;\n  ```",
    "codeExample": "var globalVar = \"I am global\"; // доступна у всьому коді\n\n  function test() {\n    console.log(globalVar); // доступ до глобальної змінної\n  }\n  test();",
    "category": "objects",
    "isFavorite": false
  },
  {
    "id": "14",
    "question": "14. Що таке анонімна функція (anonymous function)?",
    "answer": "Анонімна функція в JavaScript.\nАнонімна функція — це функція, яка не має імені. Вона часто використовується там, де функцію потрібно створити швидко і немає необхідності використовувати її повторно.\n**Приклади анонімних функцій у JavaScript:**\n**Функція як аргумент:** Анонімні функції часто передаються як аргументи до інших функцій (наприклад, у методах `map`, `filter`, `forEach`).\n   \n**Функціональний вираз:** Анонімна функція може бути присвоєна змінній.\n   ```javascript\n   const greet = function () {\n     console.log(\"Hello\");\n   };\n   greet(); // Hello\n   ```\n**Самовиконувана функція (IIFE):** Анонімна функція може бути негайно виконана.\n   ```javascript\n   (function () {\n     console.log(\"I am an IIFE\");\n   })();\n   ```\n**У стрілкових функціях:** Стрілкові функції — це синтаксично скорочений варіант анонімних функцій.\n   ```javascript\n   const add = (a, b) =&gt; a + b;\n   console.log(add(2, 3)); // 5\n   ```\n**Переваги анонімних функцій:**\n  - **_Короткий синтаксис:_** Особливо у випадку однорядкових функцій.\n  - **_Локальність:_** Використовуються лише там, де потрібні, що сприяє чистоті коду.\n**Недоліки:**\n  - **_Немає імені:_** Ускладнюється налагодження коду, оскільки у стеку викликів такі функції позначаються як ``.\n  - **_Відсутність повторного використання:_** Не можна викликати повторно без збереження в змінну або передачі куди-небудь.",
    "codeExample": "const numbers = [1, 2, 3];\n   const doubled = numbers.map(function (num) {\n     return num * 2;\n   });\n   console.log(doubled); // [2, 4, 6]",
    "category": "arrays",
    "isFavorite": false
  },
  {
    "id": "15",
    "question": "15. Що таке стрілкова функція і як вона відрізняється від звичайної функції?",
    "answer": "Стрілкова функція в JavaScript.\nСтрілкова функція (arrow function) — це скорочений синтаксис для оголошення функцій у JavaScript, введений в ES6. Вона має компактну форму і поводиться інакше, ніж звичайна функція, особливо щодо контексту `this`.\n**Синтаксис:**\n  \n**Приклад однорядкової функції:**\n  ```javascript\n  const add = (a, b) =&gt; a + b; // автоматично повертає результат\n  console.log(add(2, 3)); // 5\n  ```\n**Основні відмінності:**\n**Контекст** `this`:\n    - У стрілкових функцій немає власного `this`. Вони успадковують `this` із зовнішнього оточення.\n    - У звичайних функцій `this` залежить від способу виклику (динамічно прив'язується).\n    ```javascript\n    const obj = {\n      value: 10,\n      regularFunction: function () {\n        console.log(this.value); // 10\n      },\n      arrowFunction: () =&gt; {\n        console.log(this.value); // undefined (успадковує this із глобального контексту)\n      },\n    };\n    obj.regularFunction();\n    obj.arrowFunction();\n    ```\n**Конструктор:**\n    - Стрілкові функції не можуть використовуватися як конструктори.\n    - Виклик new зі стрілковою функцією викликає помилку.\n    ```javascript\n    const Arrow = () =&gt; {};\n    const Regular = function () {};\n    new Arrow(); // Помилка\n    new Regular(); // Працює\n    ```\n**Синтаксис:**\n    - Стрілкова функція більш лаконічна, особливо для однорядкових операцій.\n    - Звичайна функція може мати більш розгорнутий вигляд, але є універсальною.\n    ```javascript\n    // Звичайна функція\n    function multiply(a, b) {\n      return a * b;\n    }\n    // Стрілкова функція\n    const multiplyArrow = (a, b) =&gt; a * b;\n    ```\n`arguments`:\n    - У стрілкових функцій немає псевдомасиву `arguments`. Щоб отримати аргументи, слід використовувати оператор rest (...).\n    - У звичайних функцій є доступ до `arguments`.\n    ```javascript\n    const regularFunc = function () {\n      console.log(arguments); // Псевдомасив\n    };\n    const arrowFunc = (...args) =&gt; {\n      console.log(args); // Справжній масив\n    };\n    regularFunc(1, 2, 3);\n    arrowFunc(1, 2, 3);\n    ```\n**Ключове слово** `super`:\n    - Стрілкові функції успадковують `super` із зовнішнього контексту.\n    - У звичайних функцій `super` визначається залежно від їх виклику.\n**Коли використовувати:**\n  - Стрілкові функції добре підходять для коротких виразів, обробників подій, методів масивів (`map`, `filter`, `reduce`), а також там, де важливе збереження контексту `this`.\n  - Звичайні функції варто використовувати для більш складних сценаріїв, що потребують власного `this`, `arguments` або можливості виклику через `new`.",
    "codeExample": "const functionName = (param1, param2) =&gt; {\n    // тіло функції\n    return param1 + param2;\n  };",
    "category": "arrays",
    "isFavorite": false
  },
  {
    "id": "16",
    "question": "16. Які методи перебору масивів ви знаєте?",
    "answer": "Методи перебору масивів в JavaScript\nОсновні методи перебору масивів у JavaScript:\n`forEach`\n    - Викликає передану функцію для кожного елемента масиву.\n    - Нічого не повертає (завжди undefined).\n    \n`map`\n    - Створює новий масив, застосовуючи передану функцію до кожного елемента.\n    - Не змінює вихідний масив.\n    ```javascript\n    const arr = [1, 2, 3];\n    const doubled = arr.map((num) =&gt; num * 2);\n    console.log(doubled); // [2, 4, 6]\n    ```\n`filter`\n    - Створює новий масив із елементів, що відповідають умовам функції.\n    ```javascript\n    const arr = [1, 2, 3, 4];\n    const even = arr.filter((num) =&gt; num % 2 === 0);\n    console.log(even); // [2, 4]\n    ```\n`reduce`\n    - Агрегує масив в одне значення, використовуючи функцію та початкове значення.\n    ```javascript\n    const arr = [1, 2, 3];\n    const sum = arr.reduce((acc, num) =&gt; acc + num, 0);\n    console.log(sum); // 6\n    ```\n`some`\n    - Повертає true, якщо хоч один елемент відповідає умові.\n    ```javascript\n    const arr = [1, 2, 3];\n    console.log(arr.some((num) =&gt; num &gt; 2)); // true\n    ```\n`every`\n    - Повертає true, якщо всі елементи відповідають умові.\n    ```javascript\n    const arr = [2, 4, 6];\n    console.log(arr.every((num) =&gt; num % 2 === 0)); // true\n    ```\n`find`\n    - Повертає перший елемент, що відповідає умові, або undefined.\n    ```javascript\n    const arr = [1, 2, 3];\n    console.log(arr.find((num) =&gt; num &gt; 1)); // 2\n    ```\n`findIndex`\n    - Повертає індекс першого елемента, що відповідає умові, або -1.\n    ```javascript\n    const arr = [1, 2, 3];\n    console.log(arr.findIndex((num) =&gt; num &gt; 1)); // 1\n    ```\n`flatMap`\n    - Поєднує функціональність map і flat. Повертає плоский масив.\n    ```javascript\n    const arr = [1, 2, 3];\n    console.log(arr.flatMap((num) =&gt; [num, num * 2])); // [1, 2, 2, 4, 3, 6]\n    ```\n`keys`, `values`, `entries`\n    - keys: ітератор ключів (індексів).\n    - values: ітератор значень.\n    - entries: ітератор пар [індекс, значення].\n    ```javascript\n    const arr = [\"a\", \"b\", \"c\"];\n    for (let key of arr.keys()) console.log(key); // 0, 1, 2\n    for (let value of arr.values()) console.log(value); // 'a', 'b', 'c'\n    for (let [index, value] of arr.entries()) console.log(index, value); // 0 'a', 1 'b', 2 'c'\n    ```\n`for...of`\n    - Простий синтаксис для ітерації масивів.\n    ```javascript\n    const arr = [1, 2, 3];\n    for (const num of arr) console.log(num);\n    // Виведе: 1, 2, 3\n    ```\n`sort`\n    - Сортує масив на місці.\n    ```javascript\n    const arr = [3, 1, 2];\n    arr.sort((a, b) =&gt; a - b);\n    console.log(arr); // [1, 2, 3]\n    ```\n`reverse`\n    - Перевертає порядок елементів у масиві.\n    ```javascript\n    const arr = [1, 2, 3];\n    arr.reverse();\n    console.log(arr); // [3, 2, 1]\n    ```\n`slice`\n    - Повертає копію частини масиву.\n    ```javascript\n    const arr = [1, 2, 3];\n    const subArr = arr.slice(1);\n    console.log(subArr); // [2, 3]\n    ```\n`splice`\n    - Додає, видаляє або замінює елементи в масиві.\n    ```javascript\n    const arr = [1, 2, 3];\n    arr.splice(1, 1, 4); // Видаляє 1 елемент із позиції 1, додає 4\n    console.log(arr); // [1, 4, 3]\n    ```\n**Вибір методу залежить від задачі:**\n  - Для фільтрації: `filter`.\n  - Для перетворення: `map`.\n  - Для пошуку: `find` / `findIndex`.\n  - Для ітерації: `forEach` / `for...of`.",
    "codeExample": "const arr = [1, 2, 3];\n    arr.forEach((num) =&gt; console.log(num));\n    // Виведе: 1, 2, 3",
    "category": "arrays",
    "isFavorite": false
  },
  {
    "id": "17",
    "question": "17. Що таке JSON і як працювати з ним у JavaScript?",
    "answer": "JSON та робота з ним у JavaScript\n**JSON (JavaScript Object Notation)** — це текстовий формат обміну даними, що легко читається як людиною, так і комп'ютером. Його використовують для передачі даних між клієнтом і сервером. Формат базується на синтаксисі об'єктів JavaScript, але підтримується в багатьох мовах програмування.\n**Основні особливості JSON:**\n**Ключі:**\n   - Завжди рядки.\n   - Беруться в подвійні лапки (\"\").\n**Значення:**\n   - Можуть бути: рядками, числами, логічними значеннями, масивами, об'єктами, null.\n   - Не підтримує функції, undefined, NaN.\nПриклад JSON:\n  \n**Як працювати з JSON у JavaScript?**\n**Перетворення об'єкта у JSON (`JSON.stringify`)**:\n   - Використовується для перетворення JavaScript-об'єкта в JSON-рядок.\n   ```javascript\n   const user = {\n     name: \"Alice\",\n     age: 25,\n     isStudent: false,\n   };\n   const jsonString = JSON.stringify(user);\n   console.log(jsonString);\n   // Виведе: '{\"name\":\"Alice\",\"age\":25,\"isStudent\":false}'\n   ```\n**Перетворення JSON у об'єкт (`JSON.parse`)**:\n   - Використовується для перетворення JSON-рядка у JavaScript-об'єкт.\n   ```javascript\n   const jsonString = '{\"name\":\"Alice\",\"age\":25,\"isStudent\":false}';\n   const user = JSON.parse(jsonString);\n   console.log(user);\n   // Виведе: { name: 'Alice', age: 25, isStudent: false }\n   ```\n**Робота з сервером:**\n  Передача даних у форматі JSON:\nНадсилання даних:\n   - Використовуйте fetch із JSON.stringify для передачі JSON.\n   ```javascript\n   const data = { name: \"Alice\", age: 25 };\n   fetch(\"https://example.com/api\", {\n     method: \"POST\",\n     headers: { \"Content-Type\": \"application/json\" },\n     body: JSON.stringify(data),\n   });\n   ```\nОтримання даних:\n   - Використовуйте fetch із JSON.parse для обробки відповіді.\n   ```javascript\n   fetch(\"https://example.com/api\")\n     .then((response) =&gt; response.json())\n     .then((data) =&gt; console.log(data));\n   ```\n**Типові помилки:**\n**Неправильний формат JSON:**\n   ```javascript\n   const invalidJson = \"{ name: 'Alice' }\"; // Помилка: ключі та рядки без подвійних лапок\n   JSON.parse(invalidJson); // Викине помилку\n   ```\n**Перетворення циклічного об'єкта:**\n   ```javascript\n   const obj = {};\n   obj.self = obj;\n   JSON.stringify(obj); // Викине помилку: Converting circular structure to JSON\n   ```\n**Застосування JSON:**\n  - Обмін даними між клієнтом і сервером.\n  - Збереження налаштувань у файлах чи локальному сховищі.\n  - API для роботи з веб-сервісами.",
    "codeExample": "JSON\n  {\n  \"name\": \"Alice\",\n  \"age\": 25,\n  \"isStudent\": false,\n  \"courses\": [\"Math\", \"Physics\"],\n  \"address\": { \"city\": \"Kyiv\", \"zip\": \"01001\" }\n  }",
    "category": "arrays",
    "isFavorite": false
  },
  {
    "id": "18",
    "question": "18. Як виконується асинхронний код у JavaScript?",
    "answer": "Асинхронне виконання коду в JavaScript\nАсинхронний код у JavaScript виконується за допомогою подій, колбеків, промісів і `async/await`. Виконання базується на подійному циклі (Event Loop), що дозволяє обробляти асинхронні задачі поза основним потоком виконання.\n**Механізми асинхронного виконання:**\n**Події та Колбеки**\nКод виконується, коли завершується асинхронна операція (наприклад, таймер, запит до сервера).\nКолбек-функції викликаються після завершення операції.\n  \n**Проміси (`Promises`)**\n   - `Promise` представляє операцію, яка виконується асинхронно та може завершитися успішно або з помилкою.\n   - Має методи `.then` і `.catch` для обробки результату.\n   ```javascript\n   const promise = new Promise((resolve, reject) =&gt; {\n     setTimeout(() =&gt; resolve(\"Дані отримано\"), 1000);\n   });\n   promise\n     .then((data) =&gt; console.log(data)) // Виведе: Дані отримано\n     .catch((err) =&gt; console.error(err));\n   ```\n`async/await`\n   - Синтаксичний цукор для роботи з промісами.\n   - Дозволяє писати асинхронний код так, ніби він синхронний.\n   ```javascript\n   const fetchData = async () =&gt; {\n     try {\n       const response = await fetch(\n         \"https://jsonplaceholder.typicode.com/posts/1\"\n       );\n       const data = await response.json();\n       console.log(data);\n     } catch (error) {\n       console.error(\"Помилка:\", error);\n     }\n   };\n   fetchData();\n   ```\n**Ключові поняття:**\n**Event Loop (Цикл подій):**\nОсновний механізм, що дозволяє виконувати асинхронний код.\nРозподіляє задачі між:\n  - **Call Stack** (стек викликів): виконує синхронний код.\n  - **Task Queue** (черга задач): для колбеків від `setTimeout`, DOM-подій.\n  - **Microtask Queue**: для промісів та `async/await`.\n**Microtasks vs. Macrotasks**:\nMicrotasks (вищий пріоритет): Promise.then, MutationObserver.\nMacrotasks: setTimeout, setInterval, I/O, події DOM.\n  ```javascript\n  console.log(\"Початок\");\n  setTimeout(() =&gt; console.log(\"Macrotask\"), 0);\n  Promise.resolve().then(() =&gt; console.log(\"Microtask\"));\n  console.log(\"Кінець\");\n  // Виведе:\n  // Початок\n  // Кінець\n  // Microtask\n  // Macrotask\n  ```\n**Приклади:**\n**Асинхронний ланцюжок:**\n   ```javascript\n   fetch(\"https://jsonplaceholder.typicode.com/posts/1\")\n     .then((response) =&gt; response.json())\n     .then((data) =&gt; console.log(data))\n     .catch((err) =&gt; console.error(\"Помилка:\", err));\n   ```\n**Паралельне виконання:**\n   ```javascript\n   const promise1 = fetch(\"https://jsonplaceholder.typicode.com/posts/1\");\n   const promise2 = fetch(\"https://jsonplaceholder.typicode.com/posts/2\");\n   Promise.all([promise1, promise2])\n     .then((responses) =&gt; Promise.all(responses.map((r) =&gt; r.json())))\n     .then((data) =&gt; console.log(data));\n   ```\nАсинхронний код дозволяє виконувати тривалі операції без блокування головного потоку.",
    "codeExample": "setTimeout(() =&gt; {\n    console.log(\"Асинхронно через 1 секунду\");\n  }, 1000);\n  console.log(\"Цей код виконається першим\");\n  // Виведе:\n  // Цей код виконається першим\n  // Асинхронно через 1 секунду",
    "category": "arrays",
    "isFavorite": false
  },
  {
    "id": "19",
    "question": "19. Що таке Event Loop (Цикл подій)?",
    "answer": "Цикл подій (Event Loop) в JavaScript\n**Event Loop** — це механізм в JavaScript, який відповідає за обробку асинхронних операцій.\nВін працює так:\n**Call Stack (Стек викликів):** Зберігає функції, які виконуються.\n**Task Queue (Черга завдань):** Містить асинхронні колбеки (наприклад, setTimeout), готові до виконання.\n**Microtask Queue (Черга мікрозавдань):** Містить мікрозавдання, як-от Promise або MutationObserver.\n**Процес:**\nЯкщо Call Stack порожній, Event Loop бере завдання з Microtask Queue (пріоритетно) або Task Queue й переміщує їх у Call Stack для виконання.",
    "codeExample": "",
    "category": "functions",
    "isFavorite": false
  },
  {
    "id": "20",
    "question": "20. Що таке Call Stack (Стек викликів)?",
    "answer": "Стек викликів (Call Stack) в JavaScript\n**Call Stack** — це структура даних, яка працює за принципом LIFO (Last In, First Out) і використовується для відстеження виконання функцій у JavaScript.\n  - Коли викликається функція, вона додається до вершини стеку.\n  - Коли функція завершується, вона видаляється зі стеку.\n  - Якщо функція викликає іншу функцію, та додається до стеку поверх попередньої.\n**Call Stack** обробляє тільки синхронний код. Якщо стек переповнюється (наприклад, через рекурсію без базового випадку), це спричиняє помилку RangeError: `Maximum call stack size exceeded`.",
    "codeExample": "",
    "category": "functions",
    "isFavorite": false
  },
  {
    "id": "21",
    "question": "21. Що таке Task Queue (Черга завдань)?",
    "answer": "Черга завдань\n**Task Queue** — це черга, яка зберігає асинхронні завдання, готові до виконання, наприклад, колбеки з `setTimeout`, `setInterval`, або події DOM.\nКоли **Call Stack** порожній, **Event Loop** бере завдання з **Task Queue** і додає його до стеку викликів для виконання.\n**Task Queue** має нижчий пріоритет порівняно з **Microtask Queue**, тому мікрозавдання (наприклад, з `Promises`) обробляються першими, навіть якщо в **Task Queue** вже є готові завдання.",
    "codeExample": "",
    "category": "dom",
    "isFavorite": false
  },
  {
    "id": "22",
    "question": "22. Що таке Microtask Queue (Черга мікрозавдань)?",
    "answer": "**Microtask Queue** — це черга для завдань з високим пріоритетом, наприклад:\n  - Колбеки з `Promise` (наприклад, `.then`, `.catch`, `.finally`).\n  - Завдання з `MutationObserver`.\nПісля виконання кожної операції в **Call Stack**, **Event Loop** перевіряє **Microtask Queue** і виконує всі мікрозавдання, перш ніж перейти до **Task Queue**.\nЦе забезпечує швидку обробку мікрозавдань і робить їх пріоритетними над звичайними асинхронними завданнями.",
    "codeExample": "",
    "category": "dom",
    "isFavorite": false
  },
  {
    "id": "23",
    "question": "23. Як ви працюєте з асинхронним кодом у JavaScript без використання async/await? Які інші підходи ви розглядаєте для роботи з асинхронністю?",
    "answer": "Без `async/await` асинхронний код у JavaScript можна обробляти такими підходами:\n**Callbacks (Колбеки):**\n   - Передача функції як аргумент для обробки результату.\n   - Мінус: створює \"callback hell\", ускладнюючи читабельність.\n   \n**Promises:**\n   - Використання then, catch, finally для обробки асинхронності.\n   - Більш читабельний, ніж колбеки, але може бути громіздким для складних сценаріїв.\n   ```javascript\n   fetch(\"/api/data\")\n     .then((response) =&gt; response.json())\n     .then((data) =&gt; console.log(data))\n     .catch((error) =&gt; console.error(error));\n   ```\n**Event Listeners (Слухачі подій):**\n   - Реагування на асинхронні події через обробники, наприклад, addEventListener.\n   - Використовується для роботи з DOM чи подіями введення користувача.\n   ```javascript\n   button.addEventListener(\"click\", () =&gt; {\n     console.log(\"Кнопка натиснута\");\n   });\n   ```\n**RxJS (Reactive Extensions):**\n   - Використання бібліотеки для роботи з потоками даних через об'єкти Observable.\n   - Підходить для складних асинхронних сценаріїв, як-от обробка кількох подій одночасно.\n   ```javascript\n   const observable = from(fetch(\"/api/data\"));\n   observable.subscribe({\n     next: (response) =&gt; console.log(response),\n     error: (err) =&gt; console.error(err),\n   });\n   ```",
    "codeExample": "setTimeout(() =&gt; {\n     console.log(\"Дані завантажені\");\n   }, 1000);",
    "category": "objects",
    "isFavorite": false
  },
  {
    "id": "24",
    "question": "24. Яка різниця між нестрогим порівнянням == та строгим порівнянням === у JavaScript?",
    "answer": "В JavaScript `==` і `===` відрізняються способом порівняння:\n`==` (Нестроге порівняння):\n   - Виконує приведення типів (type coercion), тому значення можуть бути різних типів.\n   \n`===` (Строге порівняння):\n   Порівнює без приведення типів. Значення повинні бути одного типу.\n   ```javascript\n   \"5\" === 5; // false\n   false === 0; // false\n   null === undefined; // false\n   ```\nКоротко:\n  - Використовуйте ===, щоб уникнути неочікуваних результатів через приведення типів.\n  - == підходить лише у випадках, коли ви точно розумієте, як працює приведення.",
    "codeExample": "\"5\" == 5; // true\n   false == 0; // true\n   null == undefined; // true",
    "category": "other",
    "isFavorite": false
  },
  {
    "id": "25",
    "question": "25. Що таке прототип у JavaScript?",
    "answer": "Прототип у JavaScript — це механізм, за допомогою якого об'єкти можуть успадковувати властивості та методи від інших об'єктів.\n**Як це працює:**\nКожен об'єкт має внутрішнє посилання на свій прототип, яке називається `[[Prototype]]`.\nПрототипом об'єкта може бути інший об'єкт або `null`.\nКоли ви намагаєтесь отримати доступ до властивості або методу об'єкта, JavaScript шукає їх у цьому об'єкті. Якщо не знаходить, переходить до прототипу й так далі в ланцюжку прототипів (prototype chain).\n**Приклад:**\n  \n  - `Person.prototype` — це прототип для всіх об'єктів, створених через `Person`.\n  - Метод `greet` доступний об'єкту `user` через його прототип.\n**Прототипне наслідування:**\n  ```javascript\n  const animal = {\n    eat() {\n      console.log(\"Їм\");\n    },\n  };\n  const dog = Object.create(animal);\n  dog.bark = function () {\n    console.log(\"Гав!\");\n  };\n  dog.eat(); // Їм (успадковано з animal)\n  dog.bark(); // Гав!\n  ```\n**Ключові моменти:**\n  - Прототипи — це основа роботи з об'єктами у JavaScript.\n  - Ланцюжок прототипів завершується `null`.\n  - `Object.getPrototypeOf(obj)` дозволяє отримати прототип об'єкта.",
    "codeExample": "function Person(name) {\n    this.name = name;\n  }\n\n  Person.prototype.greet = function () {\n    console.log(`Привіт, я ${this.name}`);\n  };\n\n  const user = new Person(\"Іван\");\n  user.greet(); // Привіт, я Іван",
    "category": "objects",
    "isFavorite": false
  },
  {
    "id": "26",
    "question": "26. У чому різниця між null та undefined?",
    "answer": "різниця між null та undefined\n`null` і `undefined` — це два різні типи даних в JavaScript, які обидва означають \"відсутність значення\", але вони використовуються в різних контекстах.\n`null`:\n   - Це спеціальний об'єкт у JavaScript, що означає \"відсутність значення\" або \"порожній об'єкт\".\n   - Його зазвичай використовують, щоб явно вказати на відсутність значення або на відсутність об'єкта.\n   - Ініціалізується вручну.\n   \n`undefined`:\n   - Це примітивний тип в JavaScript, що означає, що змінна була оголошена, але їй не було присвоєно значення.\n   - Змінні без значення автоматично мають тип undefined.\n   - Також використовується як значення за умовчанням для неініціалізованих параметрів функцій.\n   ```javascript\n   let user;\n   console.log(user); // undefined\n   function test(a) {\n     console.log(a); // undefined, якщо параметр не передано\n   }\n   test();\n   ```\n**Основні відмінності:**\n  - null — це об'єкт, явно призначений для вказівки на відсутність значення.\n  - undefined — це значення, яке присвоюється змінній, коли їй не було надано значення або коли параметр функції не переданий.\n**Порівняння:**\n  - null == undefined — true (при порівнянні з == вони вважаються рівними через приведення типів).\n  - null === undefined — false (при строгому порівнянні вони не однакові, бо мають різні типи).",
    "codeExample": "let user = null; // явно вказано, що значення відсутнє",
    "category": "objects",
    "isFavorite": false
  },
  {
    "id": "27",
    "question": "27. Що таке контекст? Як можна змінювати контекст виконання функції?",
    "answer": "Контекст\n**Контекст виконання** (execution context) — це середовище, в якому виконується JavaScript-код. Контекст визначає, які змінні, функції та об'єкти доступні в процесі виконання.\nІснує кілька видів контексту:\n**Глобальний контекст:** Це початковий контекст, в якому запускається код (в браузері — це глобальний об'єкт window).\n**Контекст функції:** Кожен виклик функції створює новий контекст виконання, що дозволяє доступ до змінних і параметрів функції.\n**Контекст об'єкта:** Коли функція викликається як метод об'єкта, контекстом є цей об'єкт.\nЯк змінювати контекст виконання функції?\n`this` — це ключовий елемент контексту. Він вказує на об'єкт, що є контекстом виконання.\nМетоди для зміни контексту:\n   - `call()`: Викликає функцію з конкретним контекстом.\n   \n   - `apply()`: Теж викликає функцію з певним контекстом, але аргументи передаються у вигляді масиву.\n   ```javascript\n   function sum(a, b) {\n     console.log(this.name, a + b);\n   }\n   const person = { name: \"Оля\" };\n   sum.apply(person, [2, 3]); // Оля 5\n   ```\n   - `bind()`: Створює нову функцію з прив'язаним контекстом, яку можна викликати пізніше.\n   ```javascript\n   function show() {\n     console.log(this.name);\n   }\n   const person = { name: \"Петро\" };\n   const showPerson = show.bind(person);\n   showPerson(); // Петро\n   ```\n**Пояснення:**\n  - `call()` та `apply()` викликають функцію одразу з визначеним контекстом.\n  - `bind()` створює нову функцію, яка завжди має певний контекст, що може бути викликана пізніше.\nЗміна контексту важлива, коли потрібно працювати з методами, які викликаються в різних обставинах, або при роботі з колбеками та асинхронним кодом.",
    "codeExample": "function greet() {\n     console.log(`Привіт, ${this.name}`);\n   }\n\n   const person = { name: \"Іван\" };\n   greet.call(person); // Привіт, Іван",
    "category": "arrays",
    "isFavorite": false
  },
  {
    "id": "28",
    "question": "28. Що таке Promise? У яких випадках ви ним користуєтеся?",
    "answer": "Promise\n`Promise`— це об'єкт, який представляє результат асинхронної операції, яка може бути завершена або з успіхом, або з помилкою. Promise дозволяє працювати з асинхронним кодом більш зручним способом, ніж через колбеки.\n**Структура:**\n  - **Pending** — стан, коли операція ще не завершена.\n  - **Resolved** (Fulfilled) — стан, коли операція успішно завершена.\n  - **Rejected** — стан, коли операція завершена з помилкою.\n**Приклад створення:**\n  \n**Переваги:**\n  - **Читабельність:** Ланцюжок `.then()` дозволяє більш зручно обробляти асинхронні операції.\n  - **Помилки:** Легше обробляти помилки через `.catch()`.\n  - **Кілька операцій:** Легко працювати з кількома асинхронними задачами одночасно через `Promise.all()` або `Promise.race()`.\nPromise робить асинхронний код більш структурованим і менш громіздким порівняно з використанням колбеків.",
    "codeExample": "let promise = new Promise((resolve, reject) =&gt; {\n    let success = true;\n\n    if (success) {\n      resolve(\"Операція успішна\");\n    } else {\n      reject(\"Щось пішло не так\");\n    }\n  });\n\n  promise\n    .then((result) =&gt; console.log(result)) // Обробка успіху\n    .catch((error) =&gt; console.log(error)); // Обробка помилки",
    "category": "objects",
    "isFavorite": false
  },
  {
    "id": "29",
    "question": "29. Які особливості об’єктноорієнтованого програмування у JavaScript?",
    "answer": "ООП\nОб'єктноорієнтоване програмування (ООП) у JavaScript має кілька особливостей, оскільки мова не є класично об'єктноорієнтованою, як, наприклад, Java або C#. Однак вона підтримує об'єктноорієнтовані концепції через механізм прототипів і з введенням класів у `ES6`. Ось основні особливості ООП у JavaScript:\n**Прототипне наслідування (Prototype-based Inheritance):**\n   - JavaScript використовує прототипне наслідування, а не класове. Кожен об'єкт може мати прототип, який є іншим об'єктом, і успадковує від нього властивості та методи.\n   - Коли ви звертаєтеся до властивості об'єкта, JavaScript спочатку шукає її в самому об'єкті, а потім переходить до його прототипу.\n   \n**Функції як конструктори:**\n   - У JavaScript функції можуть бути використані як конструктори об'єктів. Це дозволяє створювати екземпляри об'єктів із певними властивостями та методами.\n   ```javascript\n   function Person(name, age) {\n     this.name = name;\n     this.age = age;\n   }\n   const user = new Person(\"Іван\", 25);\n   console.log(user.name); // Іван\n   ```\n**Класи (ES6+ класова синтаксична конструкція):**\n   - З введенням `ES6`, JavaScript отримав класову синтаксис для створення об'єктів. Це полегшує створення класів і працює на основі прототипного наслідування.\n   ```javascript\n   class Person {\n     constructor(name, age) {\n       this.name = name;\n       this.age = age;\n     }\n     greet() {\n       console.log(`Привіт, я ${this.name}`);\n     }\n   }\n   const user = new Person(\"Іван\", 25);\n   user.greet(); // Привіт, я Іван\n   ```\n**Методи та властивості:**\n   - Об'єкти можуть мати методи (функції, прив'язані до об'єктів) та властивості (дані).\n   - Методи можуть бути визначені за допомогою класів або функцій-конструкторів.\n   ```javascript\n   const person = {\n     name: \"Іван\",\n     greet() {\n       console.log(`Привіт, я ${this.name}`);\n     },\n   };\n   person.greet(); // Привіт, я Іван\n   ```\n**Інкапсуляція:**\n   - У JavaScript є можливість інкапсулювати дані, використовуючи закриті або приватні властивості за допомогою замикань. З `ES2022` також з'явилася підтримка приватних полів у класах через `#`.\n   ```javascript\n   class Person {\n     #name;\n     constructor(name) {\n       this.#name = name;\n     }\n     getName() {\n       return this.#name;\n     }\n   }\n   const person = new Person(\"Іван\");\n   console.log(person.getName()); // Іван\n   ```\n**Поліморфізм:**\n   - JavaScript підтримує поліморфізм через перезапис методів. Це означає, що різні об'єкти можуть мати однакові методи, але з різною реалізацією.\n   ```javascript\n   class Animal {\n     speak() {\n       console.log(\"Робить звук\");\n     }\n   }\n   class Dog extends Animal {\n     speak() {\n       console.log(\"Гав!\");\n     }\n   }\n   const dog = new Dog();\n   dog.speak(); // Гав!\n   ```\n**Абстракція:**\n   - Абстракція в JavaScript реалізується через класові та функціональні методи, що дозволяє приховувати складність реалізації і зберігати лише важливу інформацію для користувача.\n   - Абстракція може бути досягнута через інтерфейси або базові класи, хоча JavaScript не має явної підтримки інтерфейсів, як в інших мовах.\n**Метод new:**\n   - Ключове слово `new` використовується для створення екземплярів класів чи функцій-конструкторів, що ініціалізує новий об'єкт і встановлює прототип.\n   ```javascript\n   function Person(name) {\n     this.name = name;\n   }\n   const person = new Person(\"Іван\");\n   ```\n**Підсумок:**\n  - Прототипне наслідування замість класичного.\n  - Функції-конструктори для створення об'єктів.\n  - ES6 класи спрощують синтаксис для створення об'єктів та наслідування.\n  - Можливість реалізації інкапсуляції та поліморфізму.\n  - Абстракція через методи класів та замикання.\nJavaScript поєднує елементи класичного ООП з прототипним підходом, що дозволяє використовувати різні стилі програмування в залежності від задачі.",
    "codeExample": "const person = {\n     name: \"Іван\",\n     greet() {\n       console.log(`Привіт, я ${this.name}`);\n     },\n   };\n\n   const user = Object.create(person);\n   user.name = \"Оля\";\n   user.greet(); // Привіт, я Оля",
    "category": "objects",
    "isFavorite": false
  },
  {
    "id": "30",
    "question": "30. Як з JavaScript-коду звернутись до HTML-елемента та змінити його текст?",
    "answer": "Щоб звернутися до HTML-елемента та змінити його текст у JavaScript, можна використовувати різні методи доступу до елементів DOM.\n**Приклад:**\n  - Використовуємо getElementById(), querySelector() або інші методи для доступу до елемента.\n  - Змінюємо текст елемента за допомогою властивості textContent або innerText.\n**Приклад** з `getElementById():`\n  \n**Приклад** з `querySelector():`\n  ```html\n  \n  \n    \n      \n      Зміна тексту\n    \n    \n      Старий текст\n      \n        // Отримуємо елемент за класом\n        const element = document.querySelector(\".example\");\n        // Змінюємо текст\n        element.textContent = \"Новий текст\";\n      \n    \n  \n  ```\n**Різниця між** `textContent` і `innerText`:\n  - `textContent:` Оновлює текст у елементі, включаючи прихований текст, але не виконує рендеринг CSS.\n  - `innerText:` Оновлює текст, враховуючи стилі CSS (наприклад, схований текст не буде видимим).\nОбидва підходи працюють для зміни тексту, але textContent — це більш швидкий і загальний спосіб.",
    "codeExample": "html\n  \n  \n    \n      <meta charset=\"UTF-8\">\n      <title>Зміна тексту</title>\n    \n    \n      <p id=\"example\">Старий текст</p>\n      <script>\n        // Отримуємо елемент за ID\n        const element = document.getElementById(\"example\");\n\n        // Змінюємо текст\n        element.textContent = \"Новий текст\";\n      </script>",
    "category": "objects",
    "isFavorite": false
  },
  {
    "id": "31",
    "question": "31. Що таке деструктуризація?",
    "answer": "Деструктуризація в JavaScript — це синтаксис, який дозволяє розпаковувати значення з масивів або властивості з об'єктів у окремі змінні. Це скорочує код і робить його більш зрозумілим.\n**Деструктуризація масивів**\nРозпаковує значення елементів масиву в окремі змінні за позицією.\n**Приклад:**\n  \n**Деструктуризація об'єктів**\nРозпаковує значення властивостей об'єкта в змінні за іменами ключів.\n**Приклад:**\n  ```javascript\n  const user = { name: \"Evan\", age: 25 };\n  const { name, age } = user;\n  console.log(name); // Evan\n  console.log(age); // 25\n  ```\nДеструктуризація в функціях\nДозволяє передавати об'єкти або масиви у функцію і розпаковувати їх прямо в параметрах.\n  - **_Масиви:_**\n  ```javascript\n  function sum([a, b]) {\n    return a + b;\n  }\n  console.log(sum([10, 20])); // 30\n  ```\n  - **_Об'єкти:_**\n  ```javascript\n  function greet({ name, age }) {\n    console.log(`Привіт, ${name}, тобі ${age} років.`);\n  }\n  greet({ name: \"Evan\", age: 25 });\n  ```\n**Переваги:**\n  - Зменшує кількість коду.\n  - Полегшує роботу з вкладеними структурами.\n  - Підвищує читабельність.\nДеструктуризація — це потужний інструмент, який широко використовується у сучасному JavaScript.",
    "codeExample": "const numbers = [10, 20, 30];\n  const [a, b, c] = numbers;\n\n  console.log(a); // 10\n  console.log(b); // 20\n  console.log(c); // 30",
    "category": "arrays",
    "isFavorite": false
  },
  {
    "id": "32",
    "question": "32. Що буде, якщо звернутись до елемента масива, якого немає за індексом?",
    "answer": "Якщо звернутися до елемента масиву за індексом, якого не існує, JavaScript поверне `undefined`.\n**Причина:**\n  - У JavaScript масиви є об'єктами, і доступ до елементів масиву працює через властивості об'єкта. Якщо властивість (тобто індекс) не існує, результатом буде `undefined`.",
    "codeExample": "",
    "category": "arrays",
    "isFavorite": false
  },
  {
    "id": "33",
    "question": "33. У чому різниця між for..of та for...in?",
    "answer": "`for...of` і `for...in` використовуються для ітерації, але мають різне призначення та працюють з різними типами даних.\n**for...of**\nІтерує значення ітерабельних об'єктів, таких як масиви, рядки, об'єкти типу `Map`, `Set`, або об'єкти з реалізованим методом `Symbol.iterator`.\n  - Приклад:\n  \n  - Особливості:\n    - Підходить для роботи з масивами та іншими ітерабельними об'єктами.\n    - Використовує значення елементів.\n    - Не підходить для ітерації по об'єктах з властивостями.\n**for...in**\nІтерує ключі (властивості) об'єкта або індекси масиву.\n  - Приклад з об'єктом:\n  ```javascript\n  const obj = { name: \"Іван\", age: 25 };\n  for (const key in obj) {\n    console.log(key); // Виведе: 'name', 'age'\n  }\n  ```\n  - Приклад з масивом:\n  ```javascript\n  const array = [\"a\", \"b\", \"c\"];\n  for (const index in array) {\n    console.log(index); // Виведе: '0', '1', '2'\n  }\n  ```\n  - Особливості:\n    - Використовується для ітерації по об'єктах.\n    - Повертає ключі об'єкта або індекси масиву як рядки.\n    - Не рекомендується для масивів, оскільки включає властивості прототипу.\n**Висновок:**\n  - `for...of`: Використовуйте для роботи з масивами та іншими ітерабельними об'єктами.\n  - `for...in`: Використовуйте для ітерації по властивостях об'єкта. Не підходить для масивів.",
    "codeExample": "const array = [\"a\", \"b\", \"c\"];\n  for (const value of array) {\n    console.log(value); // Виведе: 'a', 'b', 'c'\n  }",
    "category": "arrays",
    "isFavorite": false
  },
  {
    "id": "34",
    "question": "34. Навіщо використовується оператор && логічне І?",
    "answer": "Оператор `&amp;&amp;` (логічне І) в JavaScript використовується для перевірки логічних умов і короткого замикання. Його основне призначення — повертати перше хибне значення або останнє істинне.\n**Основні випадки використання:**\n**Перевірка кількох умов:**\n   - Повертає true, якщо всі операнди істинні.\n   - Якщо хоча б один операнд хибний, повертає цей операнд.\n   \n**Коротке замикання:**\n   - Якщо перший операнд хибний, далі умови не перевіряються, і повертається його значення.\n   - Якщо перший операнд істинний, обчислюється і повертається другий.\n   ```javascript\n   const result = false &amp;&amp; console.log(\"Не виконається\"); // false\n   const value = true &amp;&amp; \"Результат\"; // 'Результат'\n   ```\n**Умовне виконання коду:**\n   - Використовується для виклику функцій або виконання дій лише при істинності умови.\n   ```javascript\n   const user = { loggedIn: true };\n   user.loggedIn &amp;&amp; console.log(\"Користувач увійшов\"); // 'Користувач увійшов'\n   ```\n**Використання в присвоєнні значень:**\n   - Якщо перший операнд істинний, результатом буде другий.\n   ```javascript\n   const value = true &amp;&amp; \"Hello\"; // 'Hello'\n   const empty = false &amp;&amp; \"World\"; // false\n   ```\n**Повернення значень:**\n   - &amp;&amp; не просто повертає true або false. Він повертає значення одного з операндів.\n   - Працює з будь-якими типами, не лише з булевими.\n   - **Приклад:**\n   ```javascript\n   console.log(\"a\" &amp;&amp; \"b\"); // 'b' (останнє істинне значення)\n   console.log(false &amp;&amp; \"b\"); // false (перше хибне значення)\n   console.log(\"a\" &amp;&amp; 0); // 0 (перше хибне значення)\n   ```\n**Висновок:**\n  - Оператор &amp;&amp; корисний для:\n    - Перевірки складених умов.\n    - Зупинки виконання при хибному значенні (коротке замикання).\n    - Умовного виконання виразів.",
    "codeExample": "const a = true;\n   const b = false;\n\n   console.log(a &amp;&amp; b); // false\n   console.log(a &amp;&amp; true); // true",
    "category": "objects",
    "isFavorite": false
  },
  {
    "id": "35",
    "question": "35. Навіщо використовується оператор || логічне АБО ?",
    "answer": "Оператор `||` (логічне АБО) в JavaScript використовується для перевірки логічних умов і короткого замикання. Його основна мета — повертати перше істинне значення або останнє хибне.\n**Основні випадки використання:**\n**Перевірка кількох умов:**\n   - Повертає true, якщо хоча б один операнд істинний.\n   - Якщо всі операнди хибні, повертає останнє хибне значення.\n   \n**Коротке замикання:**\n   - Якщо перший операнд істинний, далі умови не перевіряються, і повертається його значення.\n   - Якщо перший операнд хибний, обчислюється і повертається другий.\n   ```javascript\n   const result = true || console.log(\"Не виконається\"); // true\n   const value = false || \"Результат\"; // 'Результат'\n   ```\n**Значення за замовчуванням:**\n   - Використовується для задання дефолтного значення, якщо перше значення хибне.\n   ```javascript\n   const userName = \"\" || \"Анонім\"; // 'Анонім'\n   const number = 0 || 42; // 42\n   ```\n**Умовне виконання коду:**\n   - Логічне АБО дозволяє виконати альтернативну дію, якщо перша умова не спрацювала.\n   ```javascript\n   const isAuthorized = false;\n   isAuthorized || console.log(\"Доступ заборонено\"); // 'Доступ заборонено'\n   ```\n**Повернення значень:**\n  - || не обмежується булевими значеннями. Він повертає перше істинне значення або останнє хибне.\n  - **Приклади:**\n  ```javascript\n  console.log(\"a\" || \"b\"); // 'a' (перше істинне)\n  console.log(false || \"b\"); // 'b' (перше істинне)\n  console.log(null || undefined || 0); // 0 (останнє хибне)\n  ```\n**Висновок:**\n  - Оператор || корисний для:\n    - Перевірки чи хоча б одна умова виконується.\n    - Встановлення значень за замовчуванням.\n    - Короткого замикання для оптимізації виконання коду.",
    "codeExample": "const a = true;\n   const b = false;\n\n   console.log(a || b); // true\n   console.log(b || false); // false",
    "category": "objects",
    "isFavorite": false
  },
  {
    "id": "36",
    "question": "36. Навіщо використовується оператор !!?",
    "answer": "Оператор `!!` у JavaScript використовується для перетворення будь-якого значення в його булевий еквівалент. Це простий спосіб привести значення до `true` або `false`.\n**Як працює:**\nПерший `!`: Інвертує значення. Перетворює його на булеве, якщо це ще не було зроблено, і змінює на протилежне (істинне → хибне, хибне → істинне).\nДругий `!`: Знову інвертує значення, повертаючи початкову логіку, але вже у булевій формі.\n**Приклади:**\n  - Приведення до булевого типу:\n  \nДля чого використовується:\n**Приведення до булевого типу:**\n   - Використовується для явного переведення значення в булевий тип в умовах або перевірках.\n   ```javascript\n   const isActive = !!someVariable;\n   ```\n**Перевірка істинності значення:**\n   - Зручно для перевірки, чи значення існує або чи є воно \"істинним\".\n   ```javascript\n   if (!!userName) {\n     console.log(\"Ім'я користувача задано\");\n   }\n   ```\n**Явна демонстрація булевого результату:**\n   - Використовується, коли важливо явно показати, чи значення є істинним або хибним.\n   ```javascript\n   const isValid = !!(age &gt;= 18); // true, якщо вік &gt;= 18\n   ```\nВисновок:\n  - Оператор `!!` ефективно перетворює будь-яке значення у булеве. Це зручний інструмент для перевірок, умов та обробки даних у коді.",
    "codeExample": "console.log(!!0); // false (0 вважається \"хибним\")\n  console.log(!!1); // true (1 вважається \"істинним\")\n  console.log(!!\"\"); // false (порожній рядок — \"хибний\")\n  console.log(!!\"hello\"); // true (непорожній рядок — \"істинний\")\n  console.log(!!null); // false\n  console.log(!!undefined); // false\n  console.log(!!{}); // true (об'єкти завжди \"істинні\")\n  console.log(!![]); // true (масиви завжди \"істинні\")",
    "category": "arrays",
    "isFavorite": false
  },
  {
    "id": "37",
    "question": "37. Навіщо використовується оператор ! логічне НЕ?",
    "answer": "Оператор `!` (логічне НЕ) у JavaScript використовується для інверсії булевого значення. Він змінює істинне значення на хибне і навпаки.\n**Основні випадки використання:**\n**Інверсія булевого значення:**\nОператор `!` змінює логіку булевого виразу.\n  \n**Перетворення в булевий тип:**\nЯкщо значення не є булевим, оператор `!` автоматично приводить його до булевого типу, а потім інвертує.\n  ```javascript\n  console.log(!0); // true (0 вважається \"хибним\")\n  console.log(!\"hello\"); // false (рядок вважається \"істинним\")\n  console.log(!undefined); // true\n  ```\n**Умовні перевірки:**\nВикористовується для перевірки хибності значення.\n  ```javascript\n  const isValid = false;\n  if (!isValid) {\n    console.log(\"Не валідно\");\n  }\n  ```\n**Зворотна логіка:**\nПолегшує написання умов, які мають бути виконані при хибних значеннях.\n  ```javascript\n  const user = null;\n  if (!user) {\n    console.log(\"Користувач не знайдений\");\n  }\n  ```\nПриклади з інверсією:\n  - Інверсія:\n  ```javascript\n  const isOnline = false;\n  console.log(!isOnline); // true (зворотне значення)\n  ```\n  - Вкладені перевірки:\n  ```javascript\n  const isEmpty = !array.length; // true, якщо масив порожній\n  ```\n**Висновок:**\n  - Оператор `!` інвертує булеве значення та дозволяє зручно перевіряти хибність або істинність умов. Це базовий інструмент для роботи з логічними виразами.",
    "codeExample": "console.log(!true); // false\n  console.log(!false); // true",
    "category": "arrays",
    "isFavorite": false
  },
  {
    "id": "38",
    "question": "38. Які значення в JavaScript є хибними?",
    "answer": "У JavaScript до **хибних значень (falsy values)** належать ті, що при приведенні до булевого типу стають `false`.\n**Перелік хибних значень:**\n`false`— логічне значення \"хибність\".\n`0` — числовий нуль.\n`-0` — від'ємний нуль (рідко використовується, але технічно існує).\n`NaN` — \"не число\".\n`\"\"` — порожній рядок (подвійні лапки).\n`''` — порожній рядок (одинарні лапки).\n` (``) ` — порожній рядок (шаблонні літерали).\n`null` — відсутність значення.\n`undefined` — невизначене значення.\n**Приклади:**",
    "codeExample": "console.log(Boolean(false)); // false\n  console.log(Boolean(0)); // false\n  console.log(Boolean(\"\")); // false\n  console.log(Boolean(null)); // false\n  console.log(Boolean(undefined)); // false\n  console.log(Boolean(NaN)); // false",
    "category": "arrays",
    "isFavorite": false
  },
  {
    "id": "39",
    "question": "39. Які значення в JavaScript є правдивими?",
    "answer": "У JavaScript `правдиві значення (truthy values)` — це ті, які при приведенні до булевого типу стають `true`. Це всі значення, які не входять до списку хибних (falsy values).\n**Перелік типових правдивих значень:**\n**Непорожні рядки:**\n   \n**Числа, крім 0:**\n   ```javascript\n   console.log(Boolean(42)); // true\n   console.log(Boolean(-42)); // true\n   console.log(Boolean(Infinity)); // true\n   console.log(Boolean(-Infinity)); // true\n   ```\n**Об'єкти (включаючи порожні):**\n   ```javascript\n   console.log(Boolean({})); // true\n   console.log(Boolean([])); // true\n   ```\n**Функції:**\n   ```javascript\n   console.log(Boolean(function () {})); // true\n   ```\n**Спеціальні значення:**\n   - `Symbol()` — завжди істинний.\n   - Будь-який `BigInt`, відмінний від `0n`.",
    "codeExample": "console.log(Boolean(\"hello\")); // true\n   console.log(Boolean(\" \")); // true (навіть якщо це пробіл)\n   console.log(Boolean(\"0\")); // true",
    "category": "arrays",
    "isFavorite": false
  },
  {
    "id": "40",
    "question": "40. Як перевірити, чи є значення хибним?",
    "answer": "Щоб перевірити, чи є `значення хибним (falsy)` у JavaScript, можна скористатися приведенням до булевого типу. Ось кілька способів:\n**Використання `!` (логічного НЕ):**\n   \n   - Логічне НЕ інвертує булеве значення, і для хибного результату умова виконається.\n**Використання `Boolean()`:**\n   ```javascript\n   if (!Boolean(value)) {\n     console.log(\"Значення є хибним\");\n   }\n   ```\n   - Функція Boolean() явно перетворює значення в булеве. Якщо Boolean(value) повертає false, значення хибне.\n**Перевірка через подвійний `!!`:**\n   ```javascript\n   console.log(!!value); // true для правдивих, false для хибних\n   ```\n   - Подвійний ! використовується для явного приведення значення до булевого типу. Якщо результат false, значення хибне.\n**Список хибних значень:**\n   - Можна порівняти значення з відомими falsy values:\n   ```javascript\n   if (\n     value === false ||\n     value === 0 ||\n     value === \"\" ||\n     value === null ||\n     value === undefined ||\n     Number.isNaN(value)\n   ) {\n     console.log(\"Значення є хибним\");\n   }\n   ```\n**Приклади:**\n  ```javascript\n  console.log(!0); // true (0 є хибним)\n  console.log(!\"\"); // true (порожній рядок є хибним)\n  console.log(!undefined); // true (undefined є хибним)\n  console.log(!42); // false (число 42 є правдивим)\n  console.log(![]); // false (масив є правдивим)\n  ```\n**Висновок:**\n  - Найзручніший спосіб перевірити, чи значення хибне — використати !value.",
    "codeExample": "if (!value) {\n     console.log(\"Значення є хибним\");\n   }",
    "category": "arrays",
    "isFavorite": false
  },
  {
    "id": "41",
    "question": "41. Що таке DOM?",
    "answer": "Document Object Model\n**DOM** (Document Object Model) — це програмний інтерфейс для веб-документів, який надає структуру HTML або XML документа у вигляді дерева об'єктів. DOM дозволяє програмам та скриптам взаємодіяти з документами, змінюючи їх вміст, структуру та стиль.\n**Основні моменти:**\n**Представлення документа:** DOM представляє HTML або XML документ як дерево елементів, де кожен вузол дерева є об'єктом, що відповідає певній частині документа (наприклад, тегу, атрибуту або тексту).\n**Динамічна взаємодія:** Через DOM можна змінювати веб-сторінки на льоту. За допомогою JavaScript можна додавати, видаляти або змінювати елементи HTML, обробляти події (кліки, введення даних) та змінювати стиль елементів.\n**Структура дерева:** DOM є деревом з кореневим елементом ``, що містить елементи `` та ``, а ті, у свою чергу, містять інші елементи (наприклад, ``, ``, ``).\n**Висновок:**\n  - DOM є ключовим механізмом для взаємодії з веб-сторінками. Він дозволяє програмно змінювати структуру і зміст HTML-документів, що робить веб-сторінки динамічними та інтерактивними.",
    "codeExample": "",
    "category": "objects",
    "isFavorite": false
  },
  {
    "id": "42",
    "question": "42. Що таке розповсюдження події (Event Propogation)?",
    "answer": "Event Propogation\n**Розповсюдження події (Event Propagation)** в JavaScript — це процес, за якого подія, що сталася на одному елементі, передається іншим елементам в DOM-дереві. Розповсюдження події можна розділити на два основні етапи:\n**Фаза захоплення (Capturing phase):**\n   - Це перша фаза, коли подія \"захоплюється\" від кореня документа і йде вниз через усі батьківські елементи до того елемента, на якому була ініційована подія. Цей етап рідко використовується.\n**Фаза цільового елемента (Target phase):**\n   - Це етап, коли подія потрапляє безпосередньо на елемент, на якому вона була ініційована (наприклад, натискання на кнопку). Тепер подія обробляється саме на цьому елементі.\n**Фаза спливання (Bubbling phase):**\n   - Після обробки на цільовому елементі подія \"спливає\" (bubbles) до батьківських елементів і вище, поки не досягне кореня документа. Це основний етап, який найчастіше використовується для обробки подій.\n**Висновок:**\n  - Розповсюдження події дозволяє ефективно управляти тим, як подія поширюється по DOM-дереву. Ви можете використовувати фазу захоплення, цільову фазу або спливання для обробки подій, а також контролювати це за допомогою методів `stopPropagation()` і `stopImmediatePropagation()`.",
    "codeExample": "",
    "category": "dom",
    "isFavorite": false
  },
  {
    "id": "43",
    "question": "43. Чому результат порівняння двох схожих об'єктів є false?",
    "answer": "Порівняння двох схожих об'єктів\nУ JavaScript результат порівняння двох схожих об'єктів за допомогою оператора `==` або `===` зазвичай є `false`, навіть якщо ці об'єкти виглядають схожими, через те, як працює порівняння об'єктів у JavaScript.\n**Причина:**\n  - Об'єкти в JavaScript порівнюються за посиланням, а не за їхнім вмістом. Тобто, коли ви порівнюєте два об'єкти, перевіряється чи вони вказують на один і той самий об'єкт в пам'яті, а не чи їхні властивості однакові.\n**Приклад:**\n  \n  - Обидва об'єкти `obj1` та `obj2` мають однакові властивості, але це різні об'єкти в пам'яті. Оператор `==` та `===` порівнюють посилання на об'єкти, тому результат порівняння буде `false`.\n**Пояснення:**\n  - `==` — порівнює два значення, приводячи їх до спільного типу (для об'єктів це буде порівняння посилань).\n  - `===` — порівнює два значення без приведення типів, тому також порівнює посилання для об'єктів.\n**Як порівняти об'єкти по вмісту?**\n  - Якщо потрібно порівняти об'єкти за їхніми властивостями (по вмісту), вам слід вручну порівнювати кожну властивість або використати спеціальні методи, такі як `JSON.stringify()`:\n  ```javascript\n  console.log(JSON.stringify(obj1) === JSON.stringify(obj2)); // true\n  ```\n  - Але зверніть увагу, що цей метод не працює для порівняння складніших об'єктів, таких як об'єкти з методами чи циклічні посилання.",
    "codeExample": "const obj1 = { name: \"John\", age: 30 };\n  const obj2 = { name: \"John\", age: 30 };\n\n  onsole.log(obj1 == obj2); // false\n  onsole.log(obj1 === obj2); // false",
    "category": "objects",
    "isFavorite": false
  },
  {
    "id": "44",
    "question": "44. Який найшвидший спосіб перетворення рядка на число?",
    "answer": "Найшвидший спосіб перетворення рядка на число в JavaScript — це використання унарного оператора +.\n**Приклад:**\n  \nЦей метод є дуже швидким і ефективним, оскільки він використовує внутрішнє перетворення типів JavaScript.\n**Альтернативи:**\n`parseInt()`:\nПеретворює рядок на ціле число.\n  ```javascript\n  const num = parseInt(str, 10); // 42\n  ```\nОднак це повільніше, ніж унарний оператор +, через додаткову обробку (встановлення бази для чисел).\n`parseFloat()`:\nПеретворює рядок на число з плаваючою точкою.\n  ```javascript\n  const num = parseFloat(str); // 42\n  ```\nТакож повільніше, ніж унарний оператор.\n**Висновок:**\n  - Унарний оператор + є найшвидшим і найбільш ефективним способом перетворення рядка на число.",
    "codeExample": "const str = \"42\";\n  const num = +str;\n  console.log(num); // 42",
    "category": "other",
    "isFavorite": false
  },
  {
    "id": "45",
    "question": "45. Як записати кілька виразів в один рядок?",
    "answer": "Щоб записати кілька виразів в один рядок у JavaScript, можна використовувати крапку з комою `;` для розділення виразів.\n**Приклад:**\n  \nТут ми об’єднали три вирази в одному рядку, розділивши їх крапками з комами.\n**Важливо:**\n  - Використання крапок з комами дозволяє писати кілька інструкцій в одному рядку, але важливо не забувати про роздільники для уникнення помилок.\n  - Це не завжди є рекомендованим підходом, оскільки може погіршити читабельність коду, але в коротких ситуаціях це працює.",
    "codeExample": "let a = 5;\n  let b = 10;\n  let c = a + b;\n  console.log(c);",
    "category": "other",
    "isFavorite": false
  },
  {
    "id": "46",
    "question": "46. Що таке підняття (Hoisting)?",
    "answer": "Hoisting\nПідняття (Hoisting) — це механізм у JavaScript, при якому оголошення змінних і функцій \"піднімаються\" на початок своєї області видимості під час виконання коду, навіть якщо вони знаходяться після використання.\n**Основні моменти:**\nОголошення змінних та функцій піднімаються: JavaScript піднімає лише оголошення, а не ініціалізацію змінних або значення функцій.\nФункції: У разі функцій, які оголошуються через function (function declaration), піднімається і сама функція разом із її тілами.\nЗмінні: У разі змінних, оголошених через var, піднімається тільки оголошення, але не їх ініціалізація (значення). У результаті, змінна буде існувати, але її значення буде undefined до моменту присвоєння.\n**Приклад 1: Функції**\n  \nУ цьому прикладі виклик `greet()` працює, навіть якщо викликається до її оголошення. Це відбувається через підняття, оскільки функція повністю піднімається разом зі своїм тілом.\n**Приклад 2: Змінні**\n  ```javascript\n  console.log(a); // undefined\n  var a = 5;\n  console.log(a); // 5\n  ```\nУ цьому прикладі змінна a спочатку матиме значення undefined, оскільки лише оголошення (але не ініціалізація) змінної піднімається. Після присвоєння значення a стає 5.\n**Підняття з let та const**\nЗмінні, оголошені через let або const, не піднімаються так, як var. Вони знаходяться у \"мертвої зони\" (Temporal Dead Zone) між початком області видимості та місцем їх оголошення, що означає, що до того, як значення змінної буде присвоєно, їх не можна використовувати.\n  ```javascript\n  console.log(a); // ReferenceError: Cannot access 'a' before initialization\n  let a = 5;\n  ```\nТут виклик змінної до її ініціалізації викличе помилку, тому що змінна знаходиться в \"мертвій зоні\".\n**Висновок:**\n  - Підняття дозволяє використовувати функції та змінні до їх фактичного оголошення в коді, але для змінних, оголошених через var, значення буде undefined до присвоєння, а для змінних, оголошених через let або const, це призведе до помилки, якщо спробувати доступитися до них до ініціалізації.",
    "codeExample": "console.log(greet()); // \"Hello!\"\n  function greet() {\n    return \"Hello!\";\n  }",
    "category": "functions",
    "isFavorite": false
  },
  {
    "id": "47",
    "question": "47. Що таке область видимості (Scope)?",
    "answer": "Scope\n**Область видимості (Scope)** в JavaScript — це контекст, у якому визначаються змінні, функції та інші ідентифікатори. Область видимості визначає, де саме в коді можна звертатися до цих змінних або функцій.\n**Типи областей видимості:**\n**Глобальна область видимості:**\n   - Це область, яка доступна в будь-якому місці вашого коду.\n   - Змінні та функції, оголошені поза будь-якими функціями або блоками, мають глобальну область видимості.\n   \n**Область видимості функції (Function Scope):**\n   - Кожна функція має свою область видимості, і змінні, оголошені всередині функції, доступні тільки в цій функції.\n   ```javascript\n   function test() {\n     let localVar = \"I'm local\";\n     console.log(localVar); // Доступ до localVar всередині функції\n   }\n   test();\n   console.log(localVar); // Помилка: localVar не існує за межами функції\n   ```\n**Область видимості блоку (Block Scope):**\n   - Змінні, оголошені за допомогою `let` або `const`, мають область видимості на рівні блоку (в межах `{}`).\n   ```javascript\n   if (true) {\n     let blockVar = \"I'm block-scoped\";\n     console.log(blockVar); // Доступно всередині блоку\n   }\n   console.log(blockVar); // Помилка: blockVar не доступно поза блоком\n   ```\n**Лексичний Scope (Lexical Scope):**\n   - Лексичний `scope` визначається на етапі написання коду, а не виконання. Це означає, що область видимості функцій визначається тим, де вони були оголошені, а не тим, де вони викликаються.\n   ```javascript\n   function outer() {\n     let outerVar = \"I'm outer\";\n     function inner() {\n       console.log(outerVar); // Доступ до outerVar через лексичний scope\n     }\n     inner();\n   }\n   outer();\n   ```\n**Важливі моменти:**\n  - Глобальні змінні доступні в усьому коді, але їх використання може призвести до проблем, якщо імена змінних збігаються.\n  - Функціональні змінні доступні тільки в межах функції.\n  - Змінні в межах блоку з `let` і `const` доступні лише в тому блоці, в якому вони оголошені.\n**Підсумок:**\n  - Область видимості визначає, де змінні і функції можуть бути використані. Правильне розуміння області видимості допомагає уникати помилок, пов'язаних з доступом до змінних і функцій у некоректних місцях.",
    "codeExample": "let globalVar = \"I'm global\";\n\n   function test() {\n     console.log(globalVar); // Доступ до глобальної змінної\n   }\n\n   test();\n   console.log(globalVar); // Також доступно поза функцією",
    "category": "functions",
    "isFavorite": false
  },
  {
    "id": "48",
    "question": "48. Навіщо використовується директива use strict?",
    "answer": "use strict\nДиректива `\"use strict\"` в JavaScript вмикає строгий режим виконання, який змінює поведінку мови, роблячи її менш поблажливою до помилок. Вона допомагає писати більш безпечний і надійний код, запобігаючи потенційним проблемам.\n**Основні цілі:**\nЗаборона використання небезпечних або застарілих функцій.\nПосилення перевірок синтаксису.\nПопередження прихованих помилок, роблячи їх явними.\n**Що змінює строгий режим?**\n**Заборона використання змінних без оголошення:**\n   \n**Обмеження з `this` у функціях:**\n   - У глобальному контексті this дорівнює undefined, а не глобальному об'єкту.\n   ```javascript\n   \"use strict\";\n   function test() {\n     console.log(this); // undefined\n   }\n   test();\n   ```\n**Заборона дублювання імен параметрів функцій:**\n   ```javascript\n   \"use strict\";\n   function sum(a, a) {\n     // Помилка: дублювання імен параметрів\n     return a + a;\n   }\n   ```\n**Заборона видалення незмінних властивостей:**\n   ```javascript\n   \"use strict\";\n   delete Object.prototype; // Помилка\n   ```\n**Заборона застарілих синтаксичних конструкцій:**\nНаприклад, восьмеричні літерали (`0123`) заборонені.\n**Більш безпечна робота з об'єктами:**\n   - Запис у `read-only` властивість викликає помилку.\n   ```javascript\n   \"use strict\";\n   const obj = {};\n   Object.defineProperty(obj, \"prop\", { value: 42, writable: false });\n   obj.prop = 99; // Помилка\n   ```\n**Як використовувати?**\n  - У верхній частині файлу:\n  ```javascript\n   \"use strict\";\n    function test() { ... }\n  ```\n  - У межах певної функції:\n  ```javascript\n   function test() {\n    \"use strict\";\n    ...\n  }\n  ```\n**Чому це важливо?**\n  - Полегшує відловлення помилок під час розробки.\n  - Допомагає уникати небажаних поведінок, які можуть призводити до багів.\n  - Забезпечує сумісність із новими версіями JavaScript.\n**Висновок:**\n  `\"use strict\"` забезпечує більш жорсткий, безпечний і передбачуваний підхід до написання JavaScript-коду.",
    "codeExample": "\"use strict\";\n   myVar = 10; // Помилка: myVar не оголошена",
    "category": "objects",
    "isFavorite": false
  },
  {
    "id": "49",
    "question": "49. Яке значення має this?",
    "answer": "this\nЗначення `this` залежить від контексту:\n**Глобально або в функції (strict mode):** `this` — `undefined`.\n**Глобально або в функції (non-strict mode):** `this` — глобальний об'єкт (`window` в браузері, `global` в Node.js).\n**У методі об'єкта:** `this` посилається на об'єкт-власник методу.\n**У класі/конструкторі:** `this` — новостворений об'єкт.\n**У стрілковій функції:** `this` успадковується з контексту, де створена функція.\n**При явному прив'язуванні (call, apply, bind):** `this` визначається вручну.\n**В обробнику подій:** `this` залежить від способу прив’язки (елемент, обробник або явно встановлене).",
    "codeExample": "",
    "category": "objects",
    "isFavorite": false
  },
  {
    "id": "50",
    "question": "50. Що таке прототип об'єкта?",
    "answer": "prototype\nПрототип об'єкта — це механізм JavaScript, який дозволяє об'єктам наслідувати властивості та методи від інших об'єктів. Кожен об'єкт має внутрішнє посилання на свій прототип, доступне через `[[Prototype]]` (або через `__proto__`, хоча це застаріле).\nОсновні моменти:\n**Наслідування:** Якщо об'єкт не має властивості чи методу, JavaScript шукає їх у його прототипі.\n**Прототипний ланцюг:** Пошук триває по ланцюгу прототипів до null (де ланцюг завершується).\n**Встановлення прототипу:** Через Object.create(), Object.setPrototypeOf() або шляхом використання class.\n**Прототип об'єкта-конструктора:** Новостворені об'єкти через new успадковують прототип, заданий властивістю prototype конструктора.\nПростий приклад:",
    "codeExample": "function Animal(name) {\n    this.name = name;\n  }\n\n  Animal.prototype.speak = function () {\n    return `${this.name} makes a noise.`;\n  };\n\n  const dog = new Animal(\"Dog\");\n  console.log(dog.speak()); // \"Dog makes a noise.\"",
    "category": "objects",
    "isFavorite": false
  },
  {
    "id": "51",
    "question": "51. Що таке IIFE?",
    "answer": "Immediately Invoked Function Expression\nIIFE (Immediately Invoked Function Expression) — це функція, яка викликається одразу після її оголошення. Вона використовується для створення ізольованого локального контексту, уникаючи забруднення глобального простору імен.\nСинтаксис:\n  \nАбо\n  ```javascript\n  (() =&gt; {\n    // Код виконується одразу\n  })();\n  ```\nКлючові аспекти:\n  1. Замикання: IIFE створює новий лексичний контекст, дозволяючи ізолювати змінні.\n  2. Глобальне забруднення: Уникнення додавання змінних в глобальний об'єкт.\n  3. Одноразовий код: Зручне виконання коду, який не потрібно викликати повторно.\nПриклад:\n  ```javascript\n  (function () {\n    const message = \"Hello, IIFE!\";\n    console.log(message); // \"Hello, IIFE!\"\n  })();\n  // message недоступна за межами IIFE\n  ```",
    "codeExample": "(function () {\n    // Код виконується одразу\n  })();",
    "category": "objects",
    "isFavorite": false
  },
  {
    "id": "52",
    "question": "52. Навіщо використовується метод Function.prototype.apply?",
    "answer": "Function.prototype.apply\nМетод `Function.prototype.apply` використовується для виклику функції із вказаним значенням `this` та передачею аргументів у вигляді масиву або об'єктоподібного елемента.\n**Основні використання:**\n**Зміна контексту `this`:** Метод дозволяє вручну встановити, що буде посиланням `this` у функції.\n   \n**Передача аргументів у вигляді масиву:** Зручно викликати функції, що очікують список аргументів.\n   ```javascript\n   const numbers = [1, 2, 3, 4, 5];\n   console.log(Math.max.apply(null, numbers)); // 5\n   ```\n**Використання для наслідування:** Дає змогу викликати конструктор одного класу в контексті іншого.\n   ```javascript\n   function Animal(name) {\n     this.name = name;\n   }\n   function Dog(name, breed) {\n     Animal.apply(this, [name]);\n     this.breed = breed;\n   }\n   const myDog = new Dog(\"Rex\", \"Labrador\");\n   console.log(myDog); // { name: 'Rex', breed: 'Labrador' }\n   ```\n**Відмінність від `call`:**\n  - `apply` приймає аргументи у вигляді масиву, тоді як `call` — як список.",
    "codeExample": "const obj = { name: \"Alice\" };\n   function greet(greeting) {\n     return `${greeting}, ${this.name}`;\n   }\n   console.log(greet.apply(obj, [\"Hello\"])); // \"Hello, Alice\"",
    "category": "arrays",
    "isFavorite": false
  },
  {
    "id": "53",
    "question": "53. Навіщо використовується метод Function.prototype.call?",
    "answer": "Function.prototype.call\nМетод `Function.prototype.call` використовується для виклику функції із вказаним значенням `this` і передачею аргументів як окремого списку.\n**Основні використання:**\n**Зміна контексту `this`:** Дає можливість явно вказати, що буде значенням `this` для функції.\n   \n**Передача аргументів:**\n   - Усі аргументи передаються окремо, а не масивом.\n   ```javascript\n   function sum(a, b, c) {\n     return a + b + c;\n   }\n   console.log(sum.call(null, 1, 2, 3)); // 6\n   ```\n**Наслідування функцій:** Дозволяє викликати метод одного об’єкта для іншого.\n   ```javascript\n   const person = {\n     fullName: function () {\n       return `${this.firstName} ${this.lastName}`;\n     },\n   };\n   const john = { firstName: \"John\", lastName: \"Doe\" };\n   console.log(person.fullName.call(john)); // \"John Doe\"\n   ```\n**Імітація конструктора батьківського класу:** Використовується для виклику конструктора іншого класу.\n   ```javascript\n   function Animal(name) {\n     this.name = name;\n   }\n   function Dog(name, breed) {\n     Animal.call(this, name);\n     this.breed = breed;\n   }\n   const dog = new Dog(\"Rex\", \"Labrador\");\n   console.log(dog); // { name: 'Rex', breed: 'Labrador' }\n   ```\n**Відмінність від `apply`:**\n  - `call` приймає аргументи через список.\n  - `apply` приймає аргументи у вигляді масиву.",
    "codeExample": "const obj = { name: \"Alice\" };\n   function greet(greeting) {\n     return `${greeting}, ${this.name}`;\n   }\n   console.log(greet.call(obj, \"Hello\")); // \"Hello, Alice\"",
    "category": "arrays",
    "isFavorite": false
  },
  {
    "id": "54",
    "question": "54. У чому різниця між методами call та apply?",
    "answer": "Різниця між методами `call` та `apply` полягає у способі передачі аргументів:\n`call`:\nАргументи передаються як окремий список.\n  \n`apply`:\nАргументи передаються у вигляді масиву або об'єктоподібного елемента.\n  ```javascript\n  function greet(greeting, punctuation) {\n    return `${greeting}, ${this.name}${punctuation}`;\n  }\n  const person = { name: \"Alice\" };\n  console.log(greet.apply(person, [\"Hello\", \"!\"])); // \"Hello, Alice!\"\n  ```\n**Схожість:**\n  - Обидва змінюють контекст `this`.\n  - Використовуються для передачі аргументів до функції.\n**Коли що використовувати:**\n  - `call`: Коли аргументи відомі та передаються як список.\n  - `apply`: Коли аргументи динамічні або доступні як масив (наприклад, з `Math.max`).",
    "codeExample": "function greet(greeting, punctuation) {\n    return `${greeting}, ${this.name}${punctuation}`;\n  }\n  const person = { name: \"Alice\" };\n  console.log(greet.call(person, \"Hello\", \"!\")); // \"Hello, Alice!\"",
    "category": "arrays",
    "isFavorite": false
  },
  {
    "id": "55",
    "question": "55. Навіщо використовується метод Function.prototype.bind?",
    "answer": "Function.prototype.bind\nМетод `Function.prototype.bind` використовується для створення нової функції з фіксованим значенням `this` і, за потреби, попередньо заданими аргументами.\nОсновні використання:\n**Фіксація контексту `this`:**\n   - Дозволяє гарантувати, що функція завжди викликатиметься з визначеним `this`, незалежно від місця її виклику.\n   \n**Попереднє встановлення аргументів:**\n   - Можна частково передати аргументи, створюючи функцію із заздалегідь заповненими параметрами (каррінг).\n   ```javascript\n   function multiply(a, b) {\n     return a * b;\n   }\n   const double = multiply.bind(null, 2);\n   console.log(double(5)); // 10\n   ```\n**Використання в колбек-функціях:**\n   - Гарантує, що метод викликатиметься з правильним контекстом у функціях зворотного виклику.\n   ```javascript\n   const obj = {\n     name: \"Alice\",\n     greet() {\n       console.log(`Hello, ${this.name}`);\n     },\n   };\n   const greetFn = obj.greet.bind(obj);\n   setTimeout(greetFn, 1000); // \"Hello, Alice\"\n   ```\n**Неможливість зміни `this`:**\n   - Функція, створена через `bind`, не дозволяє змінити `this` іншими методами, наприклад, `call` чи `apply`.\nВідмінність від `call` і `apply`:\n  - `bind` створює нову функцію з прив'язаним `this`, яку можна викликати пізніше.\n  - `call` і `apply` викликають функцію негайно.",
    "codeExample": "const obj = { name: \"Alice\" };\n   function greet() {\n     return `Hello, ${this.name}`;\n   }\n   const boundGreet = greet.bind(obj);\n   console.log(boundGreet()); // \"Hello, Alice\"",
    "category": "objects",
    "isFavorite": false
  },
  {
    "id": "56",
    "question": "56. Що таке функціональне програмування?",
    "answer": "Функціональне програмування\nФункціональне програмування — це парадигма програмування, яка зосереджена на використанні функцій як основних будівельних блоків програм. Вона передбачає обробку даних через чисті функції, що не мають побічних ефектів, і використання високого рівня абстракції для маніпулювання даними.\n**Основні принципи функціонального програмування:**\n**Чисті функції:** Функції, що для однакових вхідних значень завжди повертають однакові результати і не мають побічних ефектів (не змінюють стан програми чи глобальні змінні).\n**Немутованість:** Дані не змінюються, а замість цього створюються нові значення.\n**Функції як першокласні об'єкти:** Функції можна передавати як аргументи, повертати з інших функцій і зберігати в змінних.\n**Вищий порядок функцій:** Функції, які приймають інші функції як аргументи або повертають їх.\n**Лінійна композиція:** Композиція функцій для створення нових функцій, які виконують кілька операцій в одному виразі.",
    "codeExample": "",
    "category": "objects",
    "isFavorite": false
  },
  {
    "id": "57",
    "question": "57. Які особливості JavaScript дозволяють говорити про нього як про функціональну мову програмування?",
    "answer": "Особливості JavaScript, що підтримують функціональний стиль:\n**Функції першого класу:** Функції можуть бути збережені в змінних, передаватися як аргументи іншим функціям і повертатися з функцій.\n   \n**Вищі функції:** JavaScript підтримує функції, які приймають інші функції як аргументи або повертають їх.\n   ```javascript\n   const map = (arr, fn) =&gt; arr.map(fn);\n   console.log(map([1, 2, 3], (x) =&gt; x * 2)); // [2, 4, 6]\n   ```\n**Функції-стрілки (Arrow functions):** Вони забезпечують короткий синтаксис для створення функцій, що часто використовуються в функціональному стилі.\n   ```javascript\n   const square = (x) =&gt; x * x;\n   ```\n**Методи масивів:** Методи, такі як `map`, `filter`, `reduce`, дозволяють обробляти колекції даних без змінення вихідних масивів, що є основним принципом функціонального програмування.\n   ```javascript\n   const nums = [1, 2, 3, 4];\n   const squares = nums.map((x) =&gt; x * x);\n   ```\n**Замикання:** JavaScript підтримує замикання, що дозволяє створювати функції, які мають доступ до змінних зовнішнього контексту, навіть після того, як цей контекст вже завершив своє виконання.\n   ```javascript\n   function outer(x) {\n     return function inner(y) {\n       return x + y;\n     };\n   }\n   const addFive = outer(5);\n   console.log(addFive(3)); // 8\n   ```\n**Іммутабельність через бібліотеки:** Хоча сам JavaScript не забороняє зміну даних, завдяки бібліотекам типу `Immutable.js` можна реалізувати немутованість у коді.\n   - JavaScript підтримує функціональний стиль завдяки своїм властивостям, але він також підтримує об'єктно-орієнтований і імперативний стилі програмування, що робить його мультипарадигмовою мовою.",
    "codeExample": "const add = (a, b) =&gt; a + b;\n   const multiply = (a, b) =&gt; a * b;\n   const apply = (fn, a, b) =&gt; fn(a, b);\n   console.log(apply(add, 2, 3)); // 5",
    "category": "arrays",
    "isFavorite": false
  },
  {
    "id": "58",
    "question": "58. Що таке функції вищого ладу (Higher Order Functions)?",
    "answer": "Higher Order Functions\n**Функції вищого порядку (Higher Order Functions, HOF)** — це функції, які виконують одну або кілька з наступних операцій:\nПриймають одну або кілька функцій як аргументи.\nПовертають функцію як результат.\n**Приклад:**\n  - **Функція, що приймає іншу функцію як аргумент:**\n  \n  - **Функція, що повертає іншу функцію:**\n  ```javascript\n  function multiplyBy(x) {\n    return function (y) {\n      return x * y;\n    };\n  }\n  const multiplyBy2 = multiplyBy(2);\n  console.log(multiplyBy2(5)); // 10\n  ```\n**Приклади стандартних функцій вищого порядку:**\n  - `map()`: Приймає функцію як аргумент і застосовує її до кожного елемента масиву, повертаючи новий масив.\n  ```javascript\n   const nums = [1, 2, 3];\n   const squared = nums.map(x =&gt; x \\* x);\n   console.log(squared); // [1, 4, 9]\n  ```\n  - `filter()`: Приймає функцію як аргумент для фільтрації елементів масиву.\n  ```javascript\n  const nums = [1, 2, 3, 4, 5];\n  const even = nums.filter((x) =&gt; x % 2 === 0);\n  console.log(even); // [2, 4]\n  ```\n  - `reduce()`: Приймає функцію як аргумент для зменшення масиву до одного значення.\n  ```javascript\n  const nums = [1, 2, 3, 4];\n  const sum = nums.reduce((acc, x) =&gt; acc + x, 0);\n  console.log(sum); // 10\n  ```\n**Особливості:**\n  - **Функції як аргументи** дозволяють передавати поведінку в інші функції.\n  - **Функції як результати** дозволяють створювати нові функції на основі вже існуючих, забезпечуючи високий рівень абстракції.",
    "codeExample": "function applyOperation(a, b, operation) {\n    return operation(a, b);\n  }\n\n  const add = (x, y) =&gt; x + y;\n  console.log(applyOperation(2, 3, add)); // 5",
    "category": "arrays",
    "isFavorite": false
  },
  {
    "id": "59",
    "question": "59. Чому функції у JavaScript називають об'єктами першого класу (First-class Objects)?",
    "answer": "Function -&gt; First-class Objects\nФункції в JavaScript називають **об'єктами першого класу (first-class objects)**, тому що вони володіють наступними властивостями, які характерні для об'єктів першого класу:\n**Можуть бути збережені в змінних:**\n   - Функції можуть бути присвоєні змінним або передаватися як значення.\n   \n**Можуть бути передані як аргументи іншим функціям:**\n   - Функції можуть бути передані в якості параметрів іншим функціям.\n   ```javascript\n   function callFunction(fn) {\n     fn();\n   }\n   callFunction(greet); // \"Hello!\"\n   ```\n**Можуть бути повернуті як результат з інших функцій:**\n   - Функції можуть бути повернуті іншими функціями, дозволяючи створювати нові функції на основі існуючих.\n   ```javascript\n   function createAdder(x) {\n     return function (y) {\n       return x + y;\n     };\n   }\n   const add5 = createAdder(5);\n   console.log(add5(3)); // 8\n   ```\n**Можуть бути динамічно створені в будь-який час:**\n   - Функції в JavaScript можна створювати на льоту, як анонімні функції або через функції-стрілки.\nЦі властивості роблять функції в JavaScript такими ж важливими та гнучкими, як і інші типи даних, дозволяючи використовувати їх як об'єкти першого класу в програмі.",
    "codeExample": "const greet = function () {\n     console.log(\"Hello!\");\n   };\n   greet(); // \"Hello!\"",
    "category": "objects",
    "isFavorite": false
  },
  {
    "id": "60",
    "question": "60. Що таке об'єкт arguments?",
    "answer": "arguments\nОб'єкт `arguments` — це **вбудований об'єкт**, доступний всередині функції, який містить усі аргументи, передані в цю функцію, незалежно від того, скільки параметрів було оголошено в сигнатурі функції. Він дозволяє працювати з переданими аргументами, навіть якщо їх кількість не збігається з кількістю параметрів у функції.\n**Основні характеристики об'єкта `arguments`:**\n**Масивоподібний об'єкт:**\n   - Він має індекси для кожного переданого аргументу і властивість `length`, яка вказує на кількість переданих аргументів. Однак об'єкт `arguments` не є справжнім масивом, тому не має методів масиву, таких як `map`, `forEach` тощо.\n**Доступ до аргументів за індексом:** Ви можете звертатися до переданих аргументів за індексом, як до елементів масиву.\n   \n**Кількість аргументів:** Ви можете використовувати властивість `length` для отримання кількості переданих аргументів.\n   ```javascript\n   function logArgs() {\n     console.log(arguments.length);\n   }\n   logArgs(1, 2, 3); // 3\n   ```\n**Обмеження:**\n   - Об'єкт `arguments` не підтримує методи масиву (якщо не використовувати додаткові методи для конвертації в масив).\n   - Не є доступним у стрілкових функціях, оскільки стрілкові функції не мають власного об'єкта `arguments`.\n**Приклад:**\n  ```javascript\n  function example() {\n    console.log(arguments); // Масивоподібний об'єкт\n    console.log(arguments.length); // Кількість аргументів\n    console.log(arguments[0]); // Перший аргумент\n  }\n  example(1, \"two\", true);\n  // Виведе:\n  // [1, \"two\", true]\n  // 3\n  // 1\n  ```\nПеретворення в масив:\n  - Оскільки `arguments` не є справжнім масивом, для використання масивних методів можна його перетворити в масив:\n  ```javascript\n  function example() {\n    const args = Array.from(arguments); // або [...arguments]\n    console.log(args.map((x) =&gt; x * 2));\n  }\n  example(1, 2, 3); // [2, 4, 6]\n  ```\nВикористання:\n  Об'єкт `arguments` корисний для роботи з функціями, коли кількість аргументів невідома, або коли ви хочете працювати з переданими аргументами незалежно від їх кількості.",
    "codeExample": "function sum() {\n     console.log(arguments[0]); // перший аргумент\n     console.log(arguments[1]); // другий аргумент\n   }\n   sum(1, 2); // 1 2",
    "category": "arrays",
    "isFavorite": false
  },
  {
    "id": "61",
    "question": "61. Як створити об'єкт, який не має прототипу?",
    "answer": "Object.create(null)\nЩоб створити об'єкт без прототипу в JavaScript, використовується метод `Object.create(null)`. Це створює об'єкт, який не має властивостей і методів, успадкованих від `Object.prototype`.\n**Приклад:**\n  \n**Особливості такого об'єкта:**\n**Відсутність прототипу:** Об'єкт не має стандартних методів, таких як `toString`, `hasOwnProperty`, які успадковуються від `Object.prototype`.\n**Корисний для створення чистих словників:** Використовується, якщо ви хочете створити об'єкт як чистий хеш-таблицю, де всі ключі є власними властивостями, без конфліктів із методами або властивостями прототипу.\n   ```javascript\n   const dictionary = Object.create(null);\n   dictionary.key = \"value\";\n   console.log(dictionary.key); // \"value\"\n   console.log(dictionary.toString); // undefined\n   ```\n**Обмеження:** Ви не можете безпосередньо використовувати методи `Object.prototype` (наприклад, `hasOwnProperty`), тому доведеться застосовувати їх через об'єкт `Object`.\n**Як викликати метод `hasOwnProperty` у такому об'єкті:**\n  ```javascript\n  const obj = Object.create(null);\n  obj.key = \"value\";\n  // Використання Object.prototype.hasOwnProperty\n  console.log(Object.prototype.hasOwnProperty.call(obj, \"key\")); // true\n  ```\nЦей підхід дозволяє уникати помилок, пов'язаних із успадкованими властивостями.",
    "codeExample": "const obj = Object.create(null);\n\n  console.log(obj); // {}\n  console.log(Object.getPrototypeOf(obj)); // null\n  console.log(obj.hasOwnProperty); // undefined",
    "category": "objects",
    "isFavorite": false
  },
  {
    "id": "62",
    "question": "62. Що таке ECMAScript?",
    "answer": "ECMAScript\nECMAScript (ES) — це специфікація мови програмування, яка слугує стандартом для JavaScript, а також інших мов, таких як JScript і ActionScript. Вона визначає синтаксис, семантику та базову функціональність мови програмування.\n**Основні аспекти:**\n**Стандартізація:**\n   - ECMAScript розробляється та підтримується організацією **_ECMA International_**, а саме її технічним комітетом **_TC39_**.\n**Відносини з JavaScript:**\n   - JavaScript є реалізацією специфікації ECMAScript, тобто браузери та інші середовища виконання використовують ECMAScript як основу для впровадження JavaScript.\n**Історія версій:**\n   - **_ES3 (1999):_** Перший широко підтримуваний стандарт.\n   - **_ES5 (2009):_** Додав підтримку `strict mode`, JSON, нові методи масивів.\n   - **_ES6 (ES2015):_** Значне оновлення з новими можливостями, такими як `let`, `const`, стрілкові функції, класи, модулі.\n   - Наступні версії (ES2016, ES2017 тощо) випускаються щороку, додаючи поступові покращення (наприклад, `async/await`, оператор `??`, методи `includes`).\n**Особливості ECMAScript:**\n   - Визначає синтаксис (наприклад, як оголошуються змінні, функції).\n   - Встановлює базові об'єкти (`Object`, `Array`, `Date`).\n   - Регулює поведінку виконання коду (обробка помилок, область видимості тощо).\n**Чому це важливо:**\n  - ECMAScript гарантує сумісність та стандартизацію між різними реалізаціями JavaScript у браузерах, серверах та інших середовищах.",
    "codeExample": "",
    "category": "arrays",
    "isFavorite": false
  },
  {
    "id": "63",
    "question": "63. У чому різниця між ключовими словами var, let та const?",
    "answer": "var let const\nРізниця між `var`, `let` та `const` у JavaScript пов'язана з їхньою областю видимості, можливістю перевизначення та поведінкою при використанні.\n`var`\n   - **Область видимості:** Функціональна або глобальна. `var` ігнорує блочну область (наприклад, у циклах чи умовах).\n     \n   - **Підняття (Hoisting):** Оголошення `var` піднімається на початок області, але значення залишається `undefined` до моменту присвоєння.\n     ```javascript\n     console.log(a); // undefined\n     var a = 5;\n     ```\n   - **Перевизначення:** Можна перевизначити або повторно оголосити ту саму змінну в тій же області.\n     ```javascript\n     var a = 5;\n     var a = 10; // Допустимо\n     ```\n`let`\n   - **Область видимості:** Блочна (межі {}). Значення `let` існує тільки в межах блоку, де вона оголошена.\n   ```javascript\n   if (true) {\n     let y = 20;\n   }\n   console.log(y); // Помилка: y is not defined\n   ```\n   - **Підняття (Hoisting):** Оголошення піднімається, але перебуває у \"темній зоні\" (`Temporal Dead Zone`) до моменту ініціалізації.\n   ```javascript\n   console.log(b); // Помилка: Cannot access 'b' before initialization\n   let b = 5;\n   ```\n   - **Перевизначення:** Не можна повторно оголосити змінну з тим самим ім'ям у межах однієї області.\n   ```javascript\n   let c = 10;\n   let c = 20; // Помилка: Identifier 'c' has already been declared\n   ```\n`const`\n   - Область видимості: Блочна, як і у let.\n   - Підняття (Hoisting): Аналогічно let, перебуває у \"темній зоні\".\n   - Перевизначення: Значення змінної const не можна змінити після ініціалізації.\n   ```javascript\n   const z = 30;\n   z = 40; // Помилка: Assignment to constant variable\n   ```\n   - Модифікація об’єктів: Об'єкти та масиви, оголошені через const, можуть бути змінені, але не може бути змінена сама змінна.\n   ```javascript\n   const obj = { a: 1 };\n   obj.a = 2; // Допустимо\n   obj = {}; // Помилка\n   ```\n**Коротко:**\n  | Властивість             | `var`                      | `let`              | `const`            |\n  | ----------------------- | -------------------------- | ------------------ | ------------------ |\n  | **Область видимості**   | Функціональна/глобальна    | Блочна             | Блочна             |\n  | **Підняття (Hoisting)** | Так (значення `undefined`) | Так (\"темна зона\") | Так (\"темна зона\") |\n  | **Перевизначення**      | Дозволено                  | Заборонено         | Заборонено         |\n  | **Зміна значення**      | Дозволено                  | Дозволено          | Заборонено         |",
    "codeExample": "if (true) {\n       var x = 10;\n     }\n     console.log(x); // 10",
    "category": "arrays",
    "isFavorite": false
  },
  {
    "id": "64",
    "question": "64. Що таке класи (Classes)?",
    "answer": "Classes\nКласи в JavaScript — це синтаксичний цукор над прототипним успадкуванням, яка спрощує створення об'єктів і роботи з ними. Вони були введені в ECMAScript 2015 (ES6) і дозволяють більш зручну організацію коду, схожу на інші об'єктно-орієнтовані мови.\n**Основні характеристики:**\n**Оголошення класу:** Класи визначаються за допомогою ключового слова `class`.\n   \n**Конструктор (`constructor`):**\n   - Метод, який викликається під час створення екземпляра класу.\n   - В ньому зазвичай ініціалізуються властивості об'єкта.\n   ```javascript\n   class Animal {\n     constructor(type) {\n       this.type = type;\n     }\n   }\n   const cat = new Animal(\"Cat\");\n   console.log(cat.type); // Cat\n   ```\n**Методи класу:**\n   - Методи, які є загальними для всіх екземплярів.\n   ```javascript\n   class MathOperations {\n     add(a, b) {\n       return a + b;\n     }\n   }\n   const math = new MathOperations();\n   console.log(math.add(2, 3)); // 5\n   ```\n**Статичні методи (`static`):**\n   - Прив'язані до самого класу, а не до його екземплярів.\n   ```javascript\n   class Calculator {\n     static multiply(a, b) {\n       return a * b;\n     }\n   }\n   console.log(Calculator.multiply(4, 5)); // 20\n   ```\n**Наслідування (`extends`):**\n   - Дозволяє створювати класи, що успадковують властивості та методи іншого класу.\n   ```javascript\n   class Animal {\n     constructor(name) {\n       this.name = name;\n     }\n     speak() {\n       return `${this.name} makes a noise.`;\n     }\n   }\n   class Dog extends Animal {\n     speak() {\n       return `${this.name} barks.`;\n     }\n   }\n   const dog = new Dog(\"Rex\");\n   console.log(dog.speak()); // Rex barks.\n   ```\n**Гетери та сетери:**\n   - Методи, які дозволяють отримувати або встановлювати значення властивостей.\n   ```javascript\n   class Rectangle {\n     constructor(width, height) {\n       this.width = width;\n       this.height = height;\n     }\n     get area() {\n       return this.width * this.height;\n     }\n     set resize(newWidth) {\n       this.width = newWidth;\n     }\n   }\n   const rect = new Rectangle(5, 10);\n   console.log(rect.area); // 50\n   rect.resize = 8;\n   console.log(rect.area); // 80\n   ```\n**Чому класи корисні?**\n  - **_Зрозуміла структура:_** Полегшують читання та розуміння коду.\n  - **_Інкапсуляція:_** Забезпечують приховування деталей реалізації.\n  - **_Повторне використання:_** Завдяки наслідуванню.\n  - **_Сумісність з прототипним підходом:_** Під капотом класи все ще використовують прототипи.",
    "codeExample": "class Person {\n     constructor(name, age) {\n       this.name = name;\n       this.age = age;\n     }\n     greet() {\n       return `Hi, I'm ${this.name} and I'm ${this.age} years old.`;\n     }\n   }\n\n   const person = new Person(\"Alice\", 30);\n   console.log(person.greet()); // Hi, I'm Alice and I'm 30 years old.",
    "category": "objects",
    "isFavorite": false
  },
  {
    "id": "65",
    "question": "65. Що таке шаблонні літерали (Template Literals)?",
    "answer": "Template Literals\nШаблонні літерали (`Template Literals`) — це синтаксис для створення рядків у JavaScript, який дозволяє використовувати багатоособливостей, таких як інтерполяція змінних, багаторядкові рядки та додавання виразів. Вони були введені в ES6 (ECMAScript 2015).\n**Синтаксис:**\n  - Шаблонні літерали оголошуються за допомогою зворотних лапок (``), а не звичайних лапок ' або \".\n**Основні можливості:**\nІнтерполяція змінних і виразів: Використовується синтаксис ${...} для вставлення змінних або виразів у рядок.\n   \n**Багаторядкові рядки:** Шаблонні літерали дозволяють створювати багаторядкові рядки без використання символів переносу \\n.\n   ```javascript\n   const message = `This is a\n      multi-line string.`;\n   console.log(message);\n   // This is a\n   // multi-line string.\n   ```\n**Вбудовані вирази:** В шаблон можна вставляти не лише змінні, але й будь-які JavaScript вирази.\n   ```javascript\n   const a = 5;\n   const b = 10;\n   console.log(`The sum of ${a} and ${b} is ${a + b}.`);\n   // The sum of 5 and 10 is 15.\n   ```\n**Виклик функцій у шаблоні:**\n   ```javascript\n   const getGreeting = () =&gt; \"Hello!\";\n   console.log(`${getGreeting()}, world!`);\n   // Hello!, world!\n   ```\n**Використання з тегованими шаблонними літералами (Tagged Templates):** Теговані шаблони дозволяють обробляти рядок за допомогою функції перед відображенням.\n   ```javascript\n   function tag(strings, ...values) {\n     return strings[0] + values.map((v) =&gt; v.toUpperCase()).join(\"\");\n   }\n   const name = \"Alice\";\n   console.log(tag`Hello, ${name}!`);\n   // Hello, ALICE!\n   ```\nЧому шаблонні літерали корисні:\n  1.  **Зручність і читабельність:**\n      - Спрощують створення динамічних рядків.\n      - Легше писати багаторядкові рядки.\n  2.  **Менше помилок:**\n      - Відсутність необхідності вручну конкатенувати рядки з +.\n  3.  **Розширюваність:**\n      - Можливість використовувати теговані шаблони для складних обробок тексту (наприклад, переклад, перевірка безпеки даних тощо).\n**Приклад:**\n  ```javascript\n  const user = {\n    name: \"John\",\n    age: 25,\n  };\n  const greeting = `User ${user.name} is ${user.age} years old.`;\n  console.log(greeting);\n  // User John is 25 years old.\n  ```",
    "codeExample": "const name = \"Alice\";\n   const age = 30;\n   console.log(`Hi, my name is ${name} and I am ${age} years old.`);\n   // Hi, my name is Alice and I am 30 years old.",
    "category": "arrays",
    "isFavorite": false
  },
  {
    "id": "66",
    "question": "66. Що таке модулі (Modules)?",
    "answer": "Modules\n**Модулі (Modules)** в JavaScript — це спосіб організації коду, який дозволяє розбивати програму на менші, ізольовані частини (файли) з чітко визначеними залежностями. Модулі допомагають зробити код більш структурованим, повторно використовуваним і легшим у підтримці.\n**Основні концепції модулів:**\n**Експорт (`export`):**\n    - Використовується для визначення, які частини коду модуль робить доступними для інших файлів.\n    - Існують два види експорту:\n           - Іменований експорт (export):\n      \n           - Експорт за замовчуванням (export default):\n      ```javascript\n      export default function greet() {\n        return \"Hello, world!\";\n      }\n      ```\n**Імпорт (`import`):**\n    - Використовується для підключення функцій, змінних або об'єктів з іншого модуля.\n    - Іменований імпорт:\n      ```javascript\n      import { name, greet } from \"./module.js\";\n      console.log(name); // Alice\n      console.log(greet()); // Hello!\n      ```\n    - Імпорт за замовчуванням:\n      ```javascript\n      import greet from \"./module.js\";\n      console.log(greet()); // Hello, world!\n      ```\n**Строгий режим:** Усі модулі працюють у строгому режимі (`strict mode`) за замовчуванням.\n**Одинична область видимості:**\n    - Кожен модуль має власну область видимості, що запобігає конфліктам змінних з іншими модулями.\n**Переваги модулів:**\n**Ізоляція:**\n   - Уникнення глобального простору імен.\n**Повторне використання коду:**\n   - Можливість експортувати та імпортувати компоненти між різними частинами програми.\n**Простота підтримки:**\n   - Легше працювати з невеликими частинами коду.\n**Ясність залежностей:**\n   - Модулі чітко вказують, які частини коду їм потрібні.\n**Приклад:**\n  `math.js` (модуль):\n  ```javascript\n  export const add = (a, b) =&gt; a + b;\n  export const subtract = (a, b) =&gt; a - b;\n  export default (a, b) =&gt; a \\* b; // Експорт за замовчуванням\n  ```\n  `app.js` (основний файл):\n  ```javascript\n  import multiply, { add, subtract } from \"./math.js\";\n  console.log(add(2, 3)); // 5\n  console.log(subtract(7, 4)); // 3\n  console.log(multiply(3, 4)); // 12\n  ```\n**Умови використання:** - Модулі вимагають, щоб файли були з розширенням `.js` або `.mjs`. - У браузерах потрібно використовувати атрибут `type=\"module\"` у ``:\n  ```html\n  \n  ```\n  - Для Node.js модулі доступні через import/export (ESM) або require\n    (CommonJS).\n**Різновиди модулів:**\nESM (ECMAScript Modules):\nВбудований стандарт із використанням import/export.\nСучасний підхід.\nCommonJS:\n   - Використовується в Node.js (require/module.exports).\n   - Старіший підхід, менш зручний для браузерів.",
    "codeExample": "export const name = \"Alice\";\n      export function greet() {\n        return \"Hello!\";\n      }",
    "category": "objects",
    "isFavorite": false
  },
  {
    "id": "67",
    "question": "67. Навіщо потрібен оператор опціональної послідовності?",
    "answer": "Optional Chaining\nОператор опціональної послідовності (**_Optional Chaining_**, `?.`) використовується для безпечного доступу до властивостей об'єкта або виклику методів, навіть якщо деякі з цих властивостей або методів можуть бути `null` або `undefined`. Він запобігає помилкам типу `Cannot read property of undefined`.\n**Як працює:**\n**_Перевіряє наявність властивості:_** Якщо властивість існує, повертає її значення. Інакше повертає `undefined`.\n**_Припиняє виконання, якщо значення `null` або `undefined`:_** Не викликає помилок і просто повертає `undefined`.\nПриклади використання:\n**Доступ до вкладених властивостей:**\n   - Без оператора:\n   \n   - З оператором:\n   ```javascript\n   const user = { profile: { name: \"Alice\" } };\n   console.log(user.profile?.name); // Alice\n   console.log(user.address?.city); // undefined\n   ```\n**Виклик методів:**\n   ```javascript\n   const user = {\n     greet() {\n       return \"Hello!\";\n     },\n   };\n   console.log(user.greet?.()); // Hello!\n   console.log(user.sayGoodbye?.()); // undefined\n   ```\n**Доступ до елементів масиву:**\n   ```javascript\n   const data = null;\n   console.log(data?.[0]); // undefined\n   ```\n**Комбінування з оператором Nullish Coalescing (`??`):** Для встановлення значення за замовчуванням:\n   ```javascript\n   const user = null;\n   console.log(user?.profile?.name ?? \"Default Name\"); // Default Name\n   ```\n**Навіщо це потрібно:**\n**Запобігання помилок:** Уникає аварійного завершення програми через доступ до невизначених властивостей.\n**Зручність:** Код стає коротшим і зрозумілішим.\n**Безпека:** Не потрібно вручну перевіряти кожен рівень вкладеності:\n   ```javascript\n   if (user &amp;&amp; user.profile &amp;&amp; user.profile.name) {\n     console.log(user.profile.name);\n   }\n   // Заміна:\n   console.log(user?.profile?.name);\n   ```\n**Коли використовувати:**\n  - При роботі з глибоко вкладеними об'єктами або даними, які можуть бути частково відсутні (наприклад, відповіді API).",
    "codeExample": "const user = { profile: { name: \"Alice\" } };\n   console.log(user.profile.name); // Alice\n   console.log(user.address.city); // Помилка",
    "category": "arrays",
    "isFavorite": false
  },
  {
    "id": "68",
    "question": "68. Що таке генератори?",
    "answer": "Генератори\n**Генератори** — це функції в JavaScript, які можуть призупиняти виконання та відновлювати його пізніше, що дозволяє створювати послідовності значень або керувати асинхронним кодом. Генератори визначаються за допомогою ключового слова `function*` і використовують оператор `yield` для повернення проміжних результатів.\n**Основні властивості генераторів:**\n**_Призупинення виконання:_**\n   - Використання оператора `yield` дозволяє зупинити виконання функції та повернути значення.\n**_Відновлення виконання:_**\n   - Метод `next()` відновлює виконання з того місця, де було зупинено.\n**_Ітератори:_**\n   - Генератори є ітераторами, тому їх можна використовувати в циклах `for...of` та інших контекстах ітерації.\n**Синтаксис:**\n  - Оголошення генератора:\n    \n  - Використання:\n    ```javascript\n    const gen = generatorFunction();\n    console.log(gen.next()); // { value: \"First value\", done: false }\n    console.log(gen.next()); // { value: \"Second value\", done: false }\n    console.log(gen.next()); // { value: \"Done\", done: true }\n    console.log(gen.next()); // { value: undefined, done: true }\n    ```\n**Приклади використання:**\n  1. Створення послідовностей:\n  ```javascript\n  function* count() {\n    let i = 0;\n    while (true) {\n      yield i++;\n    }\n  }\n  const counter = count();\n  console.log(counter.next().value); // 0\n  console.log(counter.next().value); // 1\n  console.log(counter.next().value); // 2\n  ```\nПеребір значень за допомогою `for...of`:\n   ```javascript\n   function* colors() {\n     yield \"red\";\n     yield \"green\";\n     yield \"blue\";\n   }\n   for (const color of colors()) {\n     console.log(color);\n   }\n   // red\n   // green\n   // blue\n   ```\nКерування асинхронним кодом: Генератори можуть бути використані для асинхронного виконання з функціями, що повертатимуть проміси:\n   ```javascript\n   function* asyncGenerator() {\n     console.log(yield Promise.resolve(\"First promise resolved\"));\n     console.log(yield Promise.resolve(\"Second promise resolved\"));\n   }\n   const gen = asyncGenerator();\n   gen.next().value.then((result) =&gt; gen.next(result).value.then(console.log));\n   ```\nСимуляція нескінченних структур:\n   ```javascript\n   function* fibonacci() {\n     let [prev, curr] = [0, 1];\n     while (true) {\n       yield curr;\n       [prev, curr] = [curr, prev + curr];\n     }\n   }\n   const fib = fibonacci();\n   console.log(fib.next().value); // 1\n   console.log(fib.next().value); // 1\n   console.log(fib.next().value); // 2\n   console.log(fib.next().value); // 3\n   ```\n**Переваги:**\nКонтроль виконання: Генератори дають змогу вручну керувати виконанням функції.\nЛегкість створення послідовностей: Простий спосіб створювати ітеративні послідовності.\nАсинхронне програмування: Спрощують управління асинхронними потоками даних (особливо до введення async/await).\nОбмеження:\nГенератори не паралельні; виконання призупиняється тільки в межах поточного виклику.\nАсинхронність у генераторах менш інтуїтивна порівняно з async/await.\nВисновок: Генератори зручні для роботи з ітераторами, асинхронним кодом та складними послідовностями.",
    "codeExample": "function* generatorFunction() {\n      yield \"First value\";\n      yield \"Second value\";\n      return \"Done\";\n    }",
    "category": "objects",
    "isFavorite": false
  },
  {
    "id": "69",
    "question": "69. Що таке регулярні вирази (RegEx)?",
    "answer": "RegEx\n**Регулярні вирази (Regular Expressions, RegEx)** — це шаблони, які використовуються для пошуку, перевірки, або маніпулювання текстом. Вони дозволяють ефективно працювати з текстовими рядками за допомогою спеціального синтаксису.\n**Основні можливості:**\n  - **_Пошук:_** Знаходження підрядків у тексті.\n  - **_Перевірка:_** Визначення, чи відповідає текст певному шаблону.\n  - **_Заміна:_** Модифікація тексту на основі відповідностей.\n**Синтаксис:**\n  - Оголошення регулярного виразу:\n    Літеральна нотація:\n    \n    Конструктор:\n    ```javascript\n    const regex = new RegExp(\"pattern\", \"flags\");\n    ```\n  - Прапори (Flags):\n    - `g` — Глобальний пошук (не зупиняється на першій відповідності).\n    - `i` — Ігнорування регістру.\n    - `m` — Багаторядковий режим.\n    - `s` — Дозволяє . збігатися з символом нового рядка.\n    - `u` — Включає підтримку Юнікоду.\n    - `y` — Суворий пошук з прив’язкою до позиції.\n**Приклади використання:**\n  - **_Пошук тексту:_**\n  ```javascript\n  const text = \"Hello World!\";\n  const regex = /world/i;\n  console.log(regex.test(text)); // true\n  ```\n  - **_Заміна тексту:_**\n  ```javascript\n  const text = \"foo bar foo\";\n  const regex = /foo/g;\n  console.log(text.replace(regex, \"baz\")); // \"baz bar baz\"\n  ```\n  - **_Витяг відповідностей:_**\n  ```javascript\n  const text = \"email@example.com\";\n  const regex = /\\w+@\\w+\\.\\w+/;\n  console.log(text.match(regex)); // [\"email@example.com\"]\n  ```\n**Основні елементи шаблонів:**\n**_Літери та цифри:_** Збігаються з буквами та цифрами буквально.\n**_Спеціальні символи:_**\n   - `.` — Будь-який символ (окрім нового рядка).\n   - `\\d` — Цифра (0-9).\n   - `\\w` — Будь-яка літера, цифра або \\_.\n   - `\\s` — Пробіл.\n   - `\\b` — Межа слова.\n   - `^` — Початок рядка.\n   - `$` — Кінець рядка.\n**_Модифікатори:_**\n   - `+` — Один або більше.\n   - `*` — Нуль або більше.\n   - `?` — Нуль або один.\n   - `{n}` — Рівно n разів.\n   - `{n,}` — Щонайменше n разів.\n   - `{n,m}` — Від n до m разів.\n**_Групи та альтернація:_**\n   - `(abc)` — Групування.\n   - `|` — Або (альтернація).\n**_Екранування:_** Щоб використовувати спеціальний символ буквально, перед ним додається `\\`:\n   ```javascript\n   const regex = /\\./;\n   console.log(\"a.b\".match(regex)); // [\".\"]\n   ```\n**Приклад складного шаблону:**\n  - Пошук номерів телефонів у форматі `+380-XX-XXX-XXXX`:\n  ```javascript\n  const regex = /\\+380-\\d{2}-\\d{3}-\\d{4}/;\n  console.log(\"+380-67-123-4567\".match(regex)); // [\"+380-67-123-4567\"]\n  ```\n**Переваги:**\nШвидка перевірка текстових шаблонів.\nУніверсальність: працюють у багатьох мовах програмування.\nПотужність: дозволяють описувати складні текстові патерни.\n**Недоліки:**\nСкладність для читання та написання складних шаблонів.\nПотенційно повільне виконання на великих текстах із неефективними виразами.\nВисновок: Регулярні вирази — незамінний інструмент для роботи з текстами, якщо розуміти їхній синтаксис і використовувати обережно.",
    "codeExample": "const regex = /pattern/flags;",
    "category": "objects",
    "isFavorite": false
  },
  {
    "id": "70",
    "question": "70. Що таке temporal dead zone?",
    "answer": "Temporal Dead Zone\n**Temporal Dead Zone (TDZ)** — це проміжок часу між початком області видимості змінної, оголошеної через let або const, і моментом, коли ця змінна фактично ініціалізується. У цей період спроба доступу до змінної призведе до помилки `ReferenceError`.\nЯк це працює:\nЗмінні, оголошені за допомогою `let` і `const`, піднімаються (`hoisting`), але не ініціалізуються.\nПоки код не досягне місця, де змінна оголошена, вона перебуває в TDZ.\nПриклад:\n  \n  - Змінна a піднята (`hoisted`) на початок блоку, але не ініціалізована.\n  - Вона перебуває у `TDZ` до моменту, коли код досягає її оголошення (`let a = 5`).\n**Особливості TDZ:**\n**_Область видимості:_** `TDZ` існує в межах блоку, функції чи скрипта, де змінна оголошена.\n   ```javascript\n   {\n     console.log(x); // ReferenceError\n     let x = 10;\n   }\n   ```\n**_Функції та TDZ:_** Якщо змінна використовується в функції до її оголошення, це також викличе `ReferenceError`.\n   ```javascript\n   function test() {\n     console.log(y); // ReferenceError\n     let y = 20;\n   }\n   ```\n**_Відмінність від var:_** Змінні, оголошені через `var`, не мають `TDZ`. Вони ініціалізуються значенням `undefined`.\n   ```javascript\n   console.log(b); // undefined\n   var b = 15;\n   ```\nНавіщо це потрібно:\n  1. Попередження помилок: `TDZ` захищає від доступу до змінної до її явного оголошення, зменшуючи кількість логічних помилок.\n  2. Забезпечення блочних областей видимості: Гарантує коректну роботу з блоками, особливо в умовах, де змінні часто переписуються.\nВисновок: `Temporal Dead Zone` — це механізм, який покращує передбачуваність і безпеку коду, але вимагає уважного дотримання порядку оголошення змінних.",
    "codeExample": "console.log(a); // ReferenceError: Cannot access 'a' before initialization\n  let a = 5;",
    "category": "functions",
    "isFavorite": false
  },
  {
    "id": "71",
    "question": "71. Яка різниця між function declaration та function expression?",
    "answer": "Різниця між `Function Declaration` та `Function Expression`\n| Властивість                    | Function Declaration                       | Function Expression                                                       |\n| ------------------------------ | ------------------------------------------ | ------------------------------------------------------------------------- |\n| **Синтаксис**                  | `function name() { ... }`                  | `const name = function() { ... };` або `const name = () =&gt; { ... };`      |\n| **Ім’я функції**               | Обов’язкове                                | Може бути анонімною                                                       |\n| **Підняття (Hoisting)**        | Піднімається повністю, доступна до виклику | Піднімається лише оголошення змінної, але не ініціалізація функції        |\n| **Використання до оголошення** | Дозволено                                  | Заборонено (отримаєте `ReferenceError`)                                   |\n| **Зручність в рекурсії**       | Просте використання через ім’я функції     | Для рекурсії потрібно використовувати ім’я змінної або `arguments.callee` |\n| **Контекст**                   | Підходить для декларативного оголошення    | Часто використовується в якості значення змінної або параметра            |\nПриклади:\n**Function Declaration**:\n**Function Expression:**\n```javascript\n// Оголошення\nconst greet = function () {\n  console.log(\"Hello!\");\n};\n// Виклик до визначення — ReferenceError\ngreet(); // Hello!\n```\nГоловні відмінності:\nПідняття:\n   - `Function Declaration` доступна до моменту оголошення завдяки hoisting.\n   - `Function Expression` не піднімається з ініціалізацією; доступна тільки після оголошення.\nГнучкість:\n   - `Function Expression` може бути анонімною, використовуватись в колбеках і як значення змінної.\n   - `Function Declaration` завжди має ім’я, зручне для читаємого та структурованого коду.\nВисновок: Використовуйте `Function Declaration` для глобальних функцій і `Function Expression` для динамічного створення або передачі функцій.",
    "codeExample": "// Оголошення\nfunction greet() {\n  console.log(\"Hello!\");\n}\n\n// Виклик до визначення — працює\ngreet(); // Hello!",
    "category": "functions",
    "isFavorite": false
  },
  {
    "id": "72",
    "question": "72. Типи таймерів у JavaScript?",
    "answer": "Типи таймерів у JavaScript\nУ JavaScript є два основні типи таймерів:\n`setTimeout`\nВикористовується для виконання коду один раз після заданої затримки (у мілісекундах).\nПовертає **ідентифікатор таймера**, який можна використовувати для скасування.\n`setInterval`\nВикористовується для виконання коду з фіксованим інтервалом часу (у мілісекундах).\nПовертає **ідентифікатор таймера**, який можна використовувати для скасування.\n```javascript\nconst intervalId = setInterval(() =&gt; {\n  console.log(\"Виконується кожні 3 секунди\");\n}, 3000);\n// Скасування інтервалу\nclearInterval(intervalId);\n```\nВажливі моменти:\nТаймери не гарантують точність виконання через обмеження в Event Loop.\nЗатримка не є мінімальним часом виконання, а лише інструкцією для Event Loop.",
    "codeExample": "const timerId = setTimeout(() =&gt; {\n  console.log(\"Виконується через 2 секунди\");\n}, 2000);\n\n// Скасування таймера\nclearTimeout(timerId);",
    "category": "dom",
    "isFavorite": false
  },
  {
    "id": "73",
    "question": "73. Які методи рядків у JavaScript ти знаєш?",
    "answer": "Методи рядків у JavaScript\nJavaScript надає різноманітні методи для роботи з рядками. Ось найпоширеніші:\n`length`\nПовертає довжину рядка.\n`toUpperCase()` / `toLowerCase()`\nПеретворює рядок у верхній або нижній регістр.\n```javascript\nconsole.log(\"hello\".toUpperCase()); // \"HELLO\"\nconsole.log(\"WORLD\".toLowerCase()); // \"world\"\n```\n`trim()`\nВидаляє пробіли з початку та кінця рядка.\n```javascript\nconst str = \"   Hello!   \";\nconsole.log(str.trim()); // \"Hello!\"\n```\n`includes()`\nПеревіряє, чи міститься підрядок у рядку. Повертає true або false.\n```javascript\nconsole.log(\"Hello, world!\".includes(\"world\")); // true\nconsole.log(\"Hello, world!\".includes(\"foo\")); // false\n```\n`indexOf()` / `lastIndexOf()`\nПовертає індекс першого або останнього входження підрядка. Повертає -1, якщо підрядок не знайдено.\n```javascript\nconsole.log(\"Hello, world!\".indexOf(\"o\")); // 4\nconsole.log(\"Hello, world!\".lastIndexOf(\"o\")); // 8\n```\n`startsWith()` / `endsWith()`\nПеревіряє, чи починається або закінчується рядок на заданий підрядок.\n```javascript\nconsole.log(\"Hello, world!\".startsWith(\"Hello\")); // true\nconsole.log(\"Hello, world!\".endsWith(\"world!\")); // true\n```\n`slice()`\nПовертає частину рядка між заданими індексами.\n```javascript\nconsole.log(\"Hello, world!\".slice(0, 5)); // \"Hello\"\nconsole.log(\"Hello, world!\".slice(-6)); // \"world!\"\n```\n`substring()`\nПодібний до slice(), але не підтримує негативні індекси.\n```javascript\nconsole.log(\"Hello, world!\".substring(0, 5)); // \"Hello\"\nconsole.log(\"Hello, world!\".substring(7)); // \"world!\"\n```\n`replace()` / `replaceAll()`\nЗамінює частини рядка.\n```javascript\nconsole.log(\"Hello, world!\".replace(\"world\", \"JavaScript\")); // \"Hello, JavaScript!\"\nconsole.log(\"Hello, world! world!\".replaceAll(\"world\", \"JS\")); // \"Hello, JS! JS!\"\n```\n`split()`\nРозділяє рядок на масив підрядків за вказаним роздільником.\n```javascript\nconsole.log(\"a,b,c\".split(\",\")); // [\"a\", \"b\", \"c\"]\n```\n`repeat()`\nПовторює рядок задану кількість разів.\n```javascript\nconsole.log(\"Ha!\".repeat(3)); // \"Ha!Ha!Ha!\"\n```\n`padStart()` / `padEnd()`\nДодає символи на початок або кінець рядка до заданої довжини.\n```javascript\nconsole.log(\"5\".padStart(3, \"0\")); // \"005\"\nconsole.log(\"5\".padEnd(3, \"0\")); // \"500\"\n```\n`charAt()` / `charCodeAt()`\nПовертає символ або код символу за заданим індексом.\n```javascript\nconsole.log(\"Hello\".charAt(1)); // \"e\"\nconsole.log(\"Hello\".charCodeAt(1)); // 101\n```\n`concat()`\nОб'єднує рядки.\n```javascript\nconsole.log(\"Hello\".concat(\", \", \"world!\")); // \"Hello, world!\"\n```\n`match()` / `matchAll()`\nШукає збіги за регулярним виразом.\n```javascript\nconsole.log(\"abc123\".match(/\\d+/)); // [\"123\"]\nconsole.log([...\"abc123abc\".matchAll(/abc/g)]); // [Array(1), Array(1)]\n```\n`toString()`\nПовертає рядкове представлення об'єкта.\n```javascript\nconst num = 123;\nconsole.log(num.toString()); // \"123\"\n```\nЦі методи дають широкий вибір для роботи з рядками в JavaScript.",
    "codeExample": "const str = \"Hello, world!\";\nconsole.log(str.length); // 13",
    "category": "arrays",
    "isFavorite": false
  },
  {
    "id": "74",
    "question": "74. Які методи масивів у JavaScript ти знаеш?",
    "answer": "Методи масивів у JavaScript\nJavaScript надає багатий набір методів для роботи з масивами. Нижче описані основні з них:\n`length`\nПовертає кількість елементів у масиві.\n`push()` / `pop()`\nДодає або видаляє елементи з кінця масиву.\n```javascript\nconst arr = [1, 2];\narr.push(3); // [1, 2, 3]\narr.pop(); // [1, 2]\n```\n`unshift()` / `shift()`\nДодає або видаляє елементи з початку масиву.\n```javascript\nconst arr = [2, 3];\narr.unshift(1); // [1, 2, 3]\narr.shift(); // [2, 3]\n```\n`forEach()`\nВиконує задану функцію для кожного елемента масиву.\n```javascript\n[1, 2, 3].forEach((num) =&gt; console.log(num));\n// Виведе: 1, 2, 3\n```\n`map()`\nСтворює новий масив, виконуючи функцію для кожного елемента.\n```javascript\nconst squared = [1, 2, 3].map((num) =&gt; num ** 2);\nconsole.log(squared); // [1, 4, 9]\n```\n`filter()`\nСтворює новий масив із елементів, що відповідають умові.\n```javascript\nconst even = [1, 2, 3, 4].filter((num) =&gt; num % 2 === 0);\nconsole.log(even); // [2, 4]\n```\n`reduce()` / `reduceRight()`\nЗводить масив до одного значення.\n```javascript\nconst sum = [1, 2, 3, 4].reduce((acc, num) =&gt; acc + num, 0);\nconsole.log(sum); // 10\n```\n`find()` / `findIndex()`\nПовертає перший елемент (або індекс), що відповідає умові.\n```javascript\nconst arr = [1, 2, 3, 4];\nconsole.log(arr.find((num) =&gt; num &gt; 2)); // 3\nconsole.log(arr.findIndex((num) =&gt; num &gt; 2)); // 2\n```\n`some()` / `every()`\nПеревіряють, чи відповідає хоча б один або всі елементи умові.\n```javascript\nconsole.log([1, 2, 3].some((num) =&gt; num &gt; 2)); // true\nconsole.log([1, 2, 3].every((num) =&gt; num &gt; 0)); // true\n```\n`sort()`\nСортує елементи масиву.\n```javascript\nconst arr = [3, 1, 4, 2];\narr.sort((a, b) =&gt; a - b); // [1, 2, 3, 4]\n```\n`reverse()`\nЗмінює порядок елементів у масиві на протилежний.\n```javascript\nconst arr = [1, 2, 3];\narr.reverse(); // [3, 2, 1]\n```\n`concat()`\nОб'єднує масиви.\n```javascript\nconst arr1 = [1, 2];\nconst arr2 = [3, 4];\nconsole.log(arr1.concat(arr2)); // [1, 2, 3, 4]\n```\n`slice()`\nПовертає частину масиву.\n```javascript\nconst arr = [1, 2, 3, 4];\nconsole.log(arr.slice(1, 3)); // [2, 3]\n```\n`splice()`\nДодає, видаляє або замінює елементи в масиві.\n```javascript\nconst arr = [1, 2, 3, 4];\narr.splice(1, 2, \"a\", \"b\"); // [1, \"a\", \"b\", 4]\n```\n`join()`\nОб'єднує елементи масиву в рядок.\n```javascript\nconst arr = [1, 2, 3];\nconsole.log(arr.join(\"-\")); // \"1-2-3\"\n```\n`flat()` / `flatMap()`\nРозгладжує вкладені масиви.\n```javascript\nconsole.log([1, [2, [3]]].flat(2)); // [1, 2, 3]\nconsole.log([1, 2, 3].flatMap((num) =&gt; [num, num * 2])); // [1, 2, 2, 4, 3, 6]\n```\n`fill()`\nЗаповнює масив одним значенням.\n```javascript\nconst arr = [1, 2, 3];\narr.fill(0, 1); // [1, 0, 0]\n```\n`Array.isArray()`\nПеревіряє, чи є об'єкт масивом.\n```javascript\nconsole.log(Array.isArray([1, 2, 3])); // true\nconsole.log(Array.isArray(\"hello\")); // false\n```\nЦі методи забезпечують гнучкість для роботи з масивами у JavaScript.",
    "codeExample": "const arr = [1, 2, 3];\nconsole.log(arr.length); // 3",
    "category": "arrays",
    "isFavorite": false
  },
  {
    "id": "75",
    "question": "75. Що таке чиста функція?",
    "answer": "Що таке чиста функція?\n**Чиста функція (Pure Function)** — це функція, яка має такі характеристики:\n**Детермінованість**:\n   - Повертає однаковий результат для одного і того ж набору вхідних даних.\n   - Наприклад, `f(x) = x + 2` завжди поверне `4`, якщо `x = 2`.\n**Відсутність побічних ефектів**:\n   - Функція не змінює зовнішній стан (наприклад, глобальні змінні, DOM, файли тощо).\n   - Всі операції виконуються лише в межах функції.\n**_Приклад чистої функції:_**\n**Ця функція:**\n  - Не змінює жодних зовнішніх змінних.\n  - Повертає однаковий результат для однакових аргументів.\n**Приклад нечистої функції:**\n```javascript\nlet counter = 0;\nfunction increment() {\n  counter++;\n  return counter;\n}\nconsole.log(increment()); // 1\nconsole.log(increment()); // 2\n```\n**Ця функція:**\n  - Змінює зовнішню змінну counter.\n  - Має побічний ефект, тому не є чистою.\n**Переваги чистих функцій:**\nПередбачуваність:\n   - Легше тестувати та налагоджувати.\nРеференційна прозорість:\n   - Ви можете замінити виклик функції її результатом без зміни логіки.\nБезпечність у паралельних обчисленнях:\n   - Відсутність побічних ефектів робить функції безпечними для багатопоточності.\nВикористання в практиці:\nЧисті функції є важливим аспектом функціонального програмування, де функції використовуються як будівельні блоки для створення складних програм. Наприклад:\n```javascript\nconst double = (x) =&gt; x * 2;\nconst square = (x) =&gt; x * x;\nconst result = [1, 2, 3, 4].map(double).map(square);\nconsole.log(result); // [4, 16, 36, 64]\n```\nТут double і square є чистими функціями.",
    "codeExample": "function add(a, b) {\n  return a + b;\n}\n\nconsole.log(add(2, 3)); // 5",
    "category": "arrays",
    "isFavorite": false
  },
  {
    "id": "76",
    "question": "76. Як визначити наявність властивості в об'єкті?",
    "answer": "Визначення властивості в об'єкті\nДля перевірки, чи існує певна властивість в об'єкті в JavaScript, можна використовувати кілька підходів:\n**Оператор `in`**\nПеревіряє наявність властивості (включаючи успадковані) в об'єкті.\n**Метод `hasOwnProperty`**\nПеревіряє лише власні властивості об'єкта (не успадковані).\n```javascript\nconst obj = { name: \"Alice\", age: 25 };\nconsole.log(obj.hasOwnProperty(\"name\")); // true\nconsole.log(obj.hasOwnProperty(\"toString\")); // false (успадкована)\n```\n**Перевірка на `undefined`**\nПрацює, якщо значення властивості не є undefined.\n```javascript\nconst obj = { name: \"Alice\", age: 25 };\nconsole.log(obj.name !== undefined); // true\nconsole.log(obj.address !== undefined); // false\n```\n**Оператор доступу з умовною перевіркою (`?.`)**\nВикористовується для перевірки вкладених властивостей.\n```javascript\nconst obj = { user: { name: \"Alice\" } };\nconsole.log(obj?.user?.name); // \"Alice\"\nconsole.log(obj?.user?.address); // undefined\n```\nРекомендація:\nВикористовуйте `in` для перевірки всіх властивостей (включаючи успадковані).\nВикористовуйте `hasOwnProperty`, якщо потрібно перевірити лише власні властивості об'єкта.",
    "codeExample": "const obj = { name: \"Alice\", age: 25 };\n\nconsole.log(\"name\" in obj); // true\nconsole.log(\"address\" in obj); // false",
    "category": "objects",
    "isFavorite": false
  },
  {
    "id": "77",
    "question": "77. Різниця між host-об'єктами та нативними об'єктами?",
    "answer": "Різниця між Host-об'єктами та Нативними об'єктами в JavaScript\nJavaScript має два типи об'єктів: **Host-об'єкти** та **Нативні об'єкти**. Розглянемо їхні відмінності:\n**Host-об'єкти**\nЦе об'єкти, які надаються середовищем виконання (браузер, Node.js тощо).\nЇхній набір залежить від середовища, в якому працює JavaScript.\nПриклади в браузері:\n  - `window`\n  - `document`\n  - `console`\n  - `XMLHttpRequest`\n  - `fetch`\n**_Приклад:_**\n**_Особливості:_**\n  - Не стандартизовані для всіх середовищ.\n  - Можуть містити специфічні методи та властивості для конкретного середовища.\n**Нативні об'єкти**\nЦе вбудовані об'єкти, які є частиною специфікації ECMAScript.\nВони доступні в будь-якому середовищі виконання JavaScript.\nПриклади:\n  - `Object`\n  - `Array`\n  - `Function`\n  - `Date`\n  - `RegExp`\n**_Приклад:_**\n```javascript\nconst arr = [1, 2, 3];\nconsole.log(arr.length); // 3\nconsole.log(new Date().getFullYear()); // Поточний рік\n```\n**_Особливості:_**\n  - Завжди однакові незалежно від середовища.\n  - Визначені стандартом ECMAScript.\nОсновні відмінності між Host-об'єктами та Нативними об'єктами\n| **Критерій**                  | **Host-об'єкти**                           | **Нативні об'єкти**                 |\n| ----------------------------- | ------------------------------------------ | ----------------------------------- |\n| **Джерело**                   | Надаються середовищем виконання            | Вбудовані у специфікацію ECMAScript |\n| **Залежність від середовища** | Залежать від середовища (браузер, Node.js) | Незалежні від середовища            |\n| **Приклади**                  | `window`, `document`, `console`            | `Object`, `Array`, `Date`           |\n| **Стандартизація**            | Може бути специфічною для середовища       | Стандартизовані в ECMAScript        |\n**Рекомендації**\n  - Використовуйте Нативні об'єкти для універсального та стандартного коду.\n  - Використовуйте Host-об'єкти лише для роботи з конкретним середовищем, наприклад, браузером або сервером Node.js.",
    "codeExample": "console.log(window.innerWidth); // Ширина вікна браузера\nconsole.log(document.title); // Назва сторінки",
    "category": "arrays",
    "isFavorite": false
  },
  {
    "id": "78",
    "question": "78. Що таке об'єктна обгортка (Wrapper Objects)?",
    "answer": "Об'єктна обгортка (Wrapper Objects)\n**Об'єктна обгортка** — це тимчасовий об'єкт, який створюється для примітивних типів (`string`, `number`, `boolean`) у JavaScript, щоб дозволити доступ до методів і властивостей, характерних для об'єктів.\nПримітиви в JavaScript самі по собі не є об'єктами, але під час доступу до методів або властивостей, JavaScript автоматично створює об'єктну обгортку.\nЯк це працює?\nКоли викликається метод або властивість примітива:\n  - JavaScript створює тимчасовий об'єкт обгортки.\n  - Здійснюється доступ до методу/властивості через цей об'єкт.\n  - Після цього об'єкт-обгортка видаляється.\nПриклади\n**Рядок (`String`)**\n**Число(`Number`)**\n```javascript\nconst num = 42;\nconsole.log(num.toFixed(2)); // \"42.00\"\n// JavaScript створює тимчасовий об'єкт Number:\n// const temp = new Number(42);\n// temp.toFixed(2); -&gt; \"42.00\"\n```\n**Булеве значення (`Boolean`)**\n```javascript\nconst bool = true;\nconsole.log(bool.toString()); // \"true\"\n// JavaScript створює тимчасовий об'єкт Boolean:\n// const temp = new Boolean(true);\n// temp.toString(); -&gt; \"true\"\n```\nОсобливості\nТимчасовість\n   - Об'єктна обгортка створюється тільки на час доступу до методів/властивостей і видаляється одразу після використання.\nНезмінність примітивів\n   - Оскільки примітиви є незмінними, зміни об'єктної обгортки не впливають на сам примітив.\n```javascript\nconst str = \"hello\";\nstr.tempProp = \"value\";\nconsole.log(str.tempProp); // undefined\n```\nПісля доступу до `str.tempProp` об'єкт-обгортка видаляється, тому змінена властивість не зберігається.\n**Різниця між об'єктами та примітивами**\n  - **_Примітиви:_** зберігають свої значення напряму.\n  - **_Об'єкти:_** є посиланням на область у пам'яті.\nРучне створення об'єктних обгорток\nХоча об'єктні обгортки створюються автоматично, їх можна створити вручну за допомогою відповідних конструкторів.\n```javascript\nconst strObj = new String(\"hello\");\nconsole.log(typeof strObj); // \"object\"\n```\nПроте такий підхід не рекомендується через непотрібність у звичайному використанні.",
    "codeExample": "const str = \"hello\";\nconsole.log(str.toUpperCase()); // \"HELLO\"\n\n// JavaScript створює тимчасовий об'єкт String:\n// const temp = new String(\"hello\");\n// temp.toUpperCase(); -&gt; \"HELLO\"",
    "category": "objects",
    "isFavorite": false
  },
  {
    "id": "79",
    "question": "79. Навіщо використовується оператор залишку (%)?",
    "answer": "Використання оператору залишку (%)?\nОператор залишку (`%`) використовується для визначення залишку від ділення одного числа на інше. Він є корисним у багатьох сценаріях програмування.\nЯк працює?\nОператор залишку обчислює залишок від ділення за формулою:\n`a % b = a - (Math.floor(a / b) * b)`\n**a** — ділене.\n**b** — дільник.\nРезультат — залишок від ділення.\nПриклади:\n**Обчислення залишку**\nРобота з від'ємними числами\nУ JavaScript залишок може бути від'ємним, якщо ділене негативне.\n```javascript\nconsole.log(-10 % 3); // -1\nconsole.log(10 % -3); // 1\n```\nЗастосування\nВизначення парності числа\n   - Якщо залишок від ділення на 2 дорівнює 0, число парне.\n   - Якщо залишок не дорівнює 0, число непарне.\n```javascript\nconst isEven = (num) =&gt; num % 2 === 0;\nconsole.log(isEven(4)); // true\nconsole.log(isEven(7)); // false\n```\nЦиклічність (наприклад, індекси в масивах)\nОператор залишку корисний для циклічного доступу до елементів.\n```javascript\nconst arr = [\"a\", \"b\", \"c\"];\nconst index = 5 % arr.length; // 5 % 3 = 2\nconsole.log(arr[index]); // \"c\"\n```\nРозподіл елементів\nНаприклад, для розподілу елементів по групах.\n```javascript\nconst groupByTwo = (arr) =&gt; {\n  const group1 = [];\n  const group2 = [];\n  arr.forEach((num) =&gt; {\n    if (num % 2 === 0) group1.push(num);\n    else group2.push(num);\n  });\n  return { group1, group2 };\n};\nconsole.log(groupByTwo([1, 2, 3, 4])); // { group1: [2, 4], group2: [1, 3] }\n```\nОбмеження значення\nНаприклад, для обмеження значень у певному діапазоні.\n```javascript\nconst maxLimit = 5;\nconsole.log(7 % maxLimit); // 2\n```\nВисновок\nОператор `%` є універсальним інструментом для роботи з залишками, перевірками на парність, циклічністю та розподілом. Його використання суттєво спрощує вирішення багатьох завдань у програмуванні.",
    "codeExample": "console.log(10 % 3); // 1 (10 = 3 * 3 + 1)\nconsole.log(25 % 4); // 1 (25 = 4 * 6 + 1)",
    "category": "arrays",
    "isFavorite": false
  },
  {
    "id": "80",
    "question": "80. Як працює boxing/unboxing у JavaScript?",
    "answer": "`boxing` / `unboxing` у JavaScript\n**Boxing** та **Unboxing** у JavaScript — це процес автоматичного перетворення між примітивними типами даних (наприклад, `number`, `string`, `boolean`) і їх об'єктними обгортками (`Number`, `String`, `Boolean`).\nBoxing (Обгортання)\n**Boxing** — це перетворення примітивного типу на об'єкт. Це відбувається автоматично, коли до примітивного значення застосовуються методи або властивості, які доступні тільки в об'єктах.\nЯк це працює?\nJavaScript створює тимчасовий об'єкт обгортки для примітивного значення.\nЗастосовує метод чи властивість.\nВидаляє тимчасовий об'єкт після використання.\nПриклад:\nПроцес:\nBoxing: створюється об'єкт `String(\"hello\")`.\nВикликається метод `toUpperCase()`.\nОб'єкт видаляється, залишаючи результат `\"HELLO\"`.\nUnboxing (Розпаковка)\n**Unboxing** — це зворотний процес, коли значення з об'єктної обгортки отримується у вигляді примітивного типу.\n**_Як це працює?_**\nJavaScript викликає методи `valueOf()` або `toString()` для об'єкта, щоб отримати його примітивне значення.\nПриклад:\n```javascript\nconst num = new Number(42);\nconsole.log(num + 8); // 50\n```\nПроцес:\nUnboxing: викликається num.valueOf(), щоб отримати 42.\nВиконується додавання: 42 + 8 = 50.\n**Об'єкти-обгортки**\n  - JavaScript має вбудовані об'єкти-обгортки для кожного примітивного типу:\n| Примітивний тип | Об'єктна обгортка |\n| --------------- | ----------------- |\n| `string`        | `String`          |\n| `number`        | `Number`          |\n| `boolean`       | `Boolean`         |\n| `symbol`        | `Symbol`          |\n| `bigint`        | `BigInt`          |\n**Приклад роботи з об'єктами-обгортками:**\n```javascript\nconst strObj = new String(\"hello\"); // Об'єкт\nconsole.log(typeof strObj); // \"object\"\nconst strPrim = strObj.valueOf(); // Примітив\nconsole.log(typeof strPrim); // \"string\"\n```\nВажливі моменти\n**Boxing — автоматичний процес:**\n   - Коли ви використовуєте методи або властивості примітивного типу.\n**Unboxing — автоматичний процес:**\n   - Відбувається, коли об'єкт використовується в контексті, який очікує примітив.\n**Різниця між примітивами та об'єктами:**\n   - Примітиви порівнюються за значенням, а об'єкти за посиланням.\nПриклад порівняння:**\n```javascript\nconst str1 = \"hello\";\nconst str2 = new String(\"hello\");\nconsole.log(str1 == str2); // true (Unboxing str2 до примітиву)\nconsole.log(str1 === str2); // false (Різні типи: примітив і об'єкт)\n```\nВисновок:\n  - Boxing і Unboxing автоматизують взаємодію між примітивними типами та об'єктами, що робить JavaScript більш гнучким для використання методів та властивостей примітивів. Це важливий механізм, який допомагає зберігати баланс між простотою та потужністю мови.",
    "codeExample": "const str = \"hello\";\nconsole.log(str.toUpperCase()); // \"HELLO\"",
    "category": "objects",
    "isFavorite": false
  },
  {
    "id": "81",
    "question": "81. Що таке мемоізація?",
    "answer": "Мемоізація\n**Мемоізація** — це техніка оптимізації, яка зберігає результати виконання функцій для уникнення повторних обчислень при однакових вхідних даних.\nЯк працює мемоізація?\nФункція перевіряє, чи результат для поточних аргументів вже збережений.\nЯкщо збережений результат знайдено, повертається він.\nЯкщо результату немає, функція обчислює його, зберігає у кеш і повертає.\nПриклад реалізації мемоізації:\n**_Переваги мемоізації:_**\n  - Підвищення продуктивності за рахунок уникнення повторних обчислень.\n  - Ефективне використання ресурсів.\n**_Недоліки мемоізації:_**\n  - Збільшення споживання пам’яті через збереження кешу.\n  - Можливість застарілих даних у кеші.\n**_Де використовується мемоізація?_**\n  - Веб-додатки (оптимізація рендерингу компонентів).\n  - Обчислення складних математичних операцій.\n  - Зберігання результатів запитів до API.",
    "codeExample": "function memoize(fn) {\n  const cache = new Map();\n\n  return function (...args) {\n    const key = JSON.stringify(args);\n\n    if (cache.has(key)) {\n      console.log(\"З кешу:\", key);\n      return cache.get(key);\n    }\n\n    const result = fn(...args);\n    cache.set(key, result);\n    return result;\n  };\n}\n\n// Оригінальна функція\nfunction slowFunction(num) {\n  console.log(\"Обчислення для:\", num);\n  return num * num;\n}\n\n// Мемоізована версія\nconst memoizedFunction = memoize(slowFunction);\n\nconsole.log(memoizedFunction(5)); // Обчислення для: 5, 25\nconsole.log(memoizedFunction(5)); // З кешу: [5], 25\nconsole.log(memoizedFunction(10)); // Обчислення для: 10, 100\nconsole.log(memoizedFunction(10)); // З кешу: [10], 100",
    "category": "functions",
    "isFavorite": false
  },
  {
    "id": "82",
    "question": "82. Різниця між глибокою (deep) та поверхневою (shallow) копіями об'єкта?",
    "answer": "Різниця між глибокою (deep) та поверхневою (shallow) копіями об'єкта\nОсновні відмінності:\n| **Критерій**      | **Поверхнева копія (Shallow Copy)**                           | **Глибока копія (Deep Copy)**                                      |\n| ----------------- | ------------------------------------------------------------- | ------------------------------------------------------------------ |\n| **Що копіюється** | Лише верхній рівень властивостей.                             | Усі рівні об'єкта, включаючи вкладені структури.                   |\n| **Залежність**    | Вкладені об'єкти копіюються за посиланням (shared reference). | Вкладені об'єкти копіюються рекурсивно, створюючи нові екземпляри. |\n| **Ризик змін**    | Зміни у вкладених об'єктах відображаються в обох копіях.      | Копія повністю незалежна від оригіналу.                            |\nЯк зробити копію?\n**Поверхнева копія (Shallow Copy)**\nСпособи створення:\n**Object.assign**:\n   \n**Spread-оператор:**\n   ```javascript\n   const original = { a: 1, b: { c: 2 } };\n   const shallowCopy = { ...original };\n   shallowCopy.b.c = 42;\n   console.log(original.b.c); // Виведе: 42\n   ```\n**Глибока копія (Deep Copy)**\nСпособи створення:\n**JSON** (для об'єктів без функцій або посилань на інші об'єкти):\n   ```javascript\n   const original = { a: 1, b: { c: 2 } };\n   const deepCopy = JSON.parse(JSON.stringify(original));\n   deepCopy.b.c = 42;\n   console.log(original.b.c); // Виведе: 2\n   ```\n**Рекурсивна функція:**\n   ```javascript\n   function deepCopy(obj) {\n     if (obj === null || typeof obj !== \"object\") return obj;\n     const copy = Array.isArray(obj) ? [] : {};\n     for (const key in obj) {\n       if (obj.hasOwnProperty(key)) {\n         copy[key] = deepCopy(obj[key]);\n       }\n     }\n     return copy;\n   }\n   const original = { a: 1, b: { c: 2 } };\n   const deepCopyObj = deepCopy(original);\n   deepCopyObj.b.c = 42;\n   console.log(original.b.c); // Виведе: 2\n   ```\n**Бібліотека Lodash:**\n   ```javascript\n   const _ = require(\"lodash\");\n   const original = { a: 1, b: { c: 2 } };\n   const deepCopy = _.cloneDeep(original);\n   deepCopy.b.c = 42;\n   console.log(original.b.c); // Виведе: 2\n   ```\n**Висновок:**\n  - Використовуйте поверхневу копію, якщо об'єкт має лише верхній рівень властивостей.\n  - Застосовуйте глибоку копію, якщо потрібно копіювати вкладені структури, щоб уникнути побічних ефектів.",
    "codeExample": "const original = { a: 1, b: { c: 2 } };\n   const shallowCopy = Object.assign({}, original);\n\n   shallowCopy.b.c = 42;\n   console.log(original.b.c); // Виведе: 42",
    "category": "arrays",
    "isFavorite": false
  },
  {
    "id": "83",
    "question": "83. Що таке ланцюжок викликів функцій (chaining)?",
    "answer": "Ланцюжок викликів функцій (chaining)\nВизначення\nЛанцюжок викликів (chaining) — це техніка в JavaScript, яка дозволяє викликати кілька методів об'єкта послідовно в одному виразі. Це досягається завдяки поверненню самого об'єкта (`this`) у кожному методі, що дозволяє викликати наступний метод без створення нового рядка коду.\nПриклад:\nОсобливості:\n**Переваги:**\n   - Зменшує кількість змінних у коді.\n   - Робить код компактнішим і легшим для читання.\n**Обмеження:**\n   - Усі методи повинні повертати об'єкт, на якому викликаються.\n   - Код може стати менш зрозумілим у разі надмірного використання.\nПриклади ланцюжка у вбудованих об'єктах:\n**Рядки:**\n```javascript\nconst result = \" JavaScript \"\n  .trim()\n  .toUpperCase()\n  .replace(\"JAVASCRIPT\", \"CHAINING\");\nconsole.log(result); // Виведе: CHAINING\n```\n**Масиви:**\n```javascript\nconst result = [1, 2, 3, 4, 5]\nfilter((num) =&gt; num % 2 === 0)\nmap((num) =&gt; num \\* 2)\nreduce((sum, num) =&gt; sum + num, 0);\nconsole.log(result); // Виведе: 12\n```\nВисновок:\nЛанцюжок викликів — потужна техніка, яка спрощує виконання послідовних операцій на одному об'єкті. Використовуйте її для покращення читабельності та скорочення коду.",
    "codeExample": "class Calculator {\n  constructor(value = 0) {\n    this.value = value;\n  }\n\n  add(number) {\n    this.value += number;\n    return this; // Повертаємо поточний об'єкт\n  }\n\n  subtract(number) {\n    this.value -= number;\n    return this; // Повертаємо поточний об'єкт\n  }\n\n  multiply(number) {\n    this.value *= number;\n    return this; // Повертаємо поточний об'єкт\n  }\n\n  divide(number) {\n    if (number !== 0) {\n      this.value /= number;\n    }\n    return this; // Повертаємо поточний об'єкт\n  }\n\n  getResult() {\n    return this.value;\n  }\n}\n\nconst result = new Calculator()\n  .add(10)\n  .subtract(2)\n  .multiply(4)\n  .divide(2)\n  .getResult();\n\nconsole.log(result); // Виведе: 16",
    "category": "arrays",
    "isFavorite": false
  },
  {
    "id": "84",
    "question": "84. Що таке неоголошена змінна?",
    "answer": "Що таке неоголошена змінна?\nВизначення\n**Неоголошена змінна** (`undeclared variable`) — це змінна, яка використовується у коді без попереднього оголошення за допомогою ключових слів `var`, `let` або `const`.\nЯк це працює?\nЯкщо змінна не оголошена, але їй присвоюється значення, JavaScript автоматично створює її як **глобальну змінну**.\nУ строгому режимі (`strict mode`) використання неоголошених змінних викликає помилку.\nПриклад без `strict mode`:\nПриклад із strict mode:\n```javascript\n\"use strict\";\nfunction example() {\n  x = 10; // Помилка: x is not defined\n}\nexample();\n```\nЧому уникати неоголошених змінних?\n**Глобальна область видимості:** Неоголошені змінні автоматично стають глобальними, що може призвести до конфліктів і помилок.\n**Важко відстежити:** Код стає менш передбачуваним і важчим для налагодження.\n**Сумісність із strict mode:** Використання строгого режиму допомагає уникнути неочікуваної поведінки.\nПравильне оголошення змінних:\nЗавжди оголошуйте змінні явно за допомогою `let`, `const` або `var`:\n```javascript\nfunction example() {\n  let x = 10; // Явно оголошена змінна\n  console.log(x); // Виведе: 10\n}\nexample();\nconsole.log(typeof x); // Виведе: undefined (x не є глобальною змінною)\n```\nВисновок:\nНеоголошені змінні можуть призвести до неочікуваної поведінки коду. Використовуйте `let` або `const` для безпечного та передбачуваного коду, а також активуйте строгий режим (`use strict`) для запобігання випадковому створенню неоголошених змінних.",
    "codeExample": "function example() {\n  x = 10; // Неоголошена змінна\n  console.log(x); // Виведе: 10\n}\n\nexample();\nconsole.log(x); // Виведе: 10 (глобальна змінна створена автоматично)",
    "category": "objects",
    "isFavorite": false
  },
  {
    "id": "85",
    "question": "85. Як передаються параметри у функцію: за посиланням чи значенням?",
    "answer": "Визначення\nУ JavaScript параметри функції передаються або **за значенням**, або **за посиланням**, в залежності від типу переданого значення.\nПараметри, що передаються за значенням:\nПримітивні типи даних (наприклад, `number`, `string`, `boolean`, `null`, `undefined`, `symbol`, `bigint`) передаються **за значенням**.\nКопія значення передається функції, і будь-які зміни цього значення всередині функції не впливають на початкову змінну.\nПриклад:\nПараметри, що передаються за посиланням:\nОб'єкти (включаючи масиви та функції) передаються **за посиланням**.\nФункція отримує посилання на оригінальний об'єкт, тому зміни всередині функції впливають на оригінальний об'єкт.\nПриклад:\n```javascript\nfunction changeObject(obj) {\n  obj.name = \"Alice\";\n}\nlet person = { name: \"Bob\" };\nchangeObject(person);\nconsole.log(person.name); // Виведе: \"Alice\" (об'єкт змінено)\n```\nЧому так відбувається?\n**Примітиви:** Примітивні значення є копіями самих себе, тому при їх передачі в функцію передається їх копія.\n**Об'єкти:** Об'єкти в JavaScript зберігаються як посилання, тому при передачі об'єкта в функцію передається посилання на нього.\nВисновок\nПримітиви передаються за значенням, тому зміни не впливають на оригінальне значення.\nОб'єкти передаються за посиланням, тому зміни в функції змінюють оригінальний об'єкт.",
    "codeExample": "function changeValue(a) {\n  a = 20;\n}\n\nlet num = 10;\nchangeValue(num);\nconsole.log(num); // Виведе: 10 (значення не змінюється)",
    "category": "arrays",
    "isFavorite": false
  },
  {
    "id": "86",
    "question": "86. Плюси та мінуси іммутабельності? Як досягти іммутабельності у JS?",
    "answer": "Іммутабельність у JavaScript\nЩо таке іммутабельність?\nІммутабельність** означає, що після створення об'єкт або значення не можуть бути змінені. Будь-яка зміна створює новий об'єкт або значення.\nПлюси іммутабельності\n**Простота налагодження:**\n   - Легше відслідковувати зміни в коді, оскільки дані не змінюються.\n**Безпека:**\n   - Зменшується ризик побічних ефектів через непередбачені зміни об'єктів.\n**Сумісність із функціональним програмуванням:**\n   - Іммутабельність є основою функціонального підходу, що покращує читабельність і тестування коду.\n**Безпека багатопоточного виконання:**\n   - У випадках, коли дані доступні кільком потокам, іммутабельні дані не потребують синхронізації.\n**Оптимізація продуктивності:**\n   - Можна використовувати техніки мемоізації або порівняння \"за посиланням\" (`===`).\nМінуси іммутабельності\n**Витрати пам'яті:**\n   - Кожна зміна створює нову копію об'єкта або масиву, що може збільшувати використання пам'яті.\n**Зниження продуктивності:**\n   - Створення нових об'єктів і копіювання даних може бути повільнішим, ніж зміна існуючих об'єктів.\n**Ускладнення роботи:**\n   - Іноді потрібні додаткові бібліотеки або техніки для підтримки іммутабельності (наприклад, `Immutable.js`).\nЯк досягти іммутабельності у JavaScript?\n**Для примітивів:**\n   - Примітиви у JavaScript вже іммутабельні.\n**Для об'єктів:**\n   - Використовуйте методи створення копій, такі як `Object.assign` або спред-оператор.\nПриклад:\n**Для масивів:**\nВикористовуйте методи, які не змінюють оригінальний масив (наприклад, map, filter, concat).\n**Приклад:**\n```javascript\nconst original = [1, 2, 3];\nconst updated = [...original, 4];\nconsole.log(original); // [1, 2, 3]\nconsole.log(updated); // [1, 2, 3, 4]\n```\n**Використовуйте `Object.freeze`:**\nЗаморожує об'єкт, забороняючи його зміну.\n**Приклад:**\n```javascript\nconst frozen = Object.freeze({ name: \"Alice\" });\nfrozen.name = \"Bob\"; // Не змінить значення, у суворому режимі викличе помилку\nconsole.log(frozen); // { name: \"Alice\" }\n```\n**Застосовуйте бібліотеки:**\nВикористовуйте спеціалізовані бібліотеки для роботи з іммутабельними структурами даних (наприклад, Immutable.js або Immer).\nВисновок\nІммутабельність робить код передбачуванішим і безпечнішим, але може збільшувати використання пам'яті та ускладнювати роботу. Її доцільно використовувати, коли важливі чистота даних, багатопотоковість або функціональний підхід.",
    "codeExample": "const original = { name: \"Alice\", age: 25 };\nconst copy = { ...original, age: 30 };\n\nconsole.log(original); // { name: \"Alice\", age: 25 }\nconsole.log(copy); // { name: \"Alice\", age: 30 }",
    "category": "arrays",
    "isFavorite": false
  },
  {
    "id": "87",
    "question": "87. Типи спливаючих вікон JavaScript?",
    "answer": "Типи спливаючих вікон у JavaScript\nJavaScript підтримує три основні типи спливаючих вікон для взаємодії з користувачем:\n`alert`\nВикористовується для відображення простого повідомлення.\nНе дозволяє взаємодію з рештою сторінки, поки користувач не закриє вікно.\nПриклад:\n`confirm`\nВикористовується для підтвердження дії користувачем.\nПовертає true, якщо користувач натиснув \"OK\", і false, якщо натиснув \"Cancel\".\nПриклад:\n```javascript\nif (confirm(\"Ви впевнені?\")) {\n  console.log(\"Користувач підтвердив.\");\n} else {\n  console.log(\"Користувач скасував.\");\n}\n```\n`prompt`\nДозволяє користувачеві ввести текст.\nПовертає введений текст, або null, якщо користувач натиснув \"Cancel\".\nПриклад:\n```javascript\nconst name = prompt(\"Введіть ваше ім'я:\");\nif (name) {\n  console.log(`Привіт, ${name}!`);\n} else {\n  console.log(\"Користувач нічого не ввів.\");\n}\n```\nВажливі моменти\nЦі методи є синхронними: блокують виконання коду, поки користувач не взаємодіє з вікном.\nЇх не рекомендується використовувати у сучасних веб-додатках через негативний вплив на UX.\nКраще використовувати кастомні модальні вікна, реалізовані на HTML, CSS і JavaScript, для кращого контролю над зовнішнім виглядом і поведінкою.",
    "codeExample": "alert(\"Це інформаційне повідомлення.\");",
    "category": "other",
    "isFavorite": false
  },
  {
    "id": "88",
    "question": "88. Типи об'єктів JavaScript?",
    "answer": "Типи об'єктів у JavaScript\nУ JavaScript існують різні типи об'єктів, які можна класифікувати наступним чином:\n**Нативні об'єкти (Native Objects)**\nЦе вбудовані об'єкти, визначені стандартом ECMAScript.\n**Приклади:**\n  - `Object`\n  - `Array`\n  - `Function`\n  - `Date`\n  - `RegExp`\n  - `Error`\n  - `Promise`\n**Глобальні об'єкти (Global Objects)**\nДоступні в будь-якому контексті без необхідності створення чи імпорту.\n**Приклади:**\n  - `Math`\n  - `JSON`\n  - `console`\n  - `globalThis`\n**Об'єкти середовища виконання (Host Objects)**\nНадаються середовищем виконання (браузер або Node.js).\n**Браузер:**\n  - `window`\n  - `document`\n  - `HTMLElement`\n  - `localStorage`\n**Node.js:**\n  - `process`\n  - `Buffer`\n  - `require`\n**Користувацькі об'єкти (User-Defined Objects)**\nОб'єкти, створені користувачем вручну.\nПриклад створення:\nСпеціалізовані об'єкти (Specialized Objects)\nЦе об'єкти, створені через функції-конструктори або класи.\n  - Приклади:\n    - `Map`, `Set`, `WeakMap`, `WeakSet`\n    - `Int8Array`, `Uint8Array`, `ArrayBuffer`\n    - `Symbol`\n**Прототипні об'єкти (Prototype Objects)**\n   - Об'єкти, які слугують прототипами для інших об'єктів.\n   - Всі об'єкти мають властивість [[Prototype]], яку можна отримати через Object.getPrototypeOf() або **proto**.\n**Приклад:**\n```javascript\nconst parent = {\n  greet() {\n    console.log(\"Привіт\");\n  },\n};\nconst child = Object.create(parent);\nchild.greet(); // \"Привіт\"\n```\nКоротке резюме\n| **Тип об'єкта**    | **Приклади**                              |\n| ------------------ | ----------------------------------------- |\n| Нативні            | `Object`, `Array`, `Date`, `Promise`      |\n| Глобальні          | `Math`, `JSON`, `console`, `globalThis`   |\n| Об'єкти середовища | `window`, `document`, `process`, `Buffer` |\n| Користувацькі      | Об'єкти, створені вручну                  |\n| Спеціалізовані     | `Map`, `Set`, `ArrayBuffer`, `Symbol`     |\n| Прототипні         | `Object.prototype`, кастомні прототипи    |",
    "codeExample": "const user = {\n  name: \"Alice\",\n  age: 25,\n  greet() {\n    console.log(`Привіт, я ${this.name}`);\n  },\n};",
    "category": "arrays",
    "isFavorite": false
  },
  {
    "id": "89",
    "question": "89. Парадигми програмування JavaScript?",
    "answer": "Парадигми програмування в JavaScript\nJavaScript підтримує кілька парадигм програмування, що робить його потужною мовою для різних завдань.\n| **Парадигма**                  | **Опис**                                                                                                                                     |\n| ------------------------------ | -------------------------------------------------------------------------------------------------------------------------------------------- |\n| **Імперативне програмування**  | Фокус на покроковому описі логіки виконання. Код визначає, як виконувати задачу.                                                             |\n| **Декларативне програмування** | Замість опису, як виконувати задачу, описується, що має бути виконано. Приклад: маніпуляції DOM за допомогою бібліотек (React, Vue).         |\n| **Об'єктно-орієнтоване**       | Організація коду навколо об'єктів, що мають властивості та методи. Підтримується прототипне наслідування.                                    |\n| **Функціональне**              | Використання функцій як першокласних об'єктів, уникання змінюваних даних, чисті функції, каррінг, композиція функцій.                        |\n| **Асинхронне**                 | Обробка асинхронного коду через колбеки, проміси, `async/await`, що дозволяє ефективно працювати з I/O операціями та таймерами.              |\n| **Реактивне**                  | Обробка потоків даних у реальному часі за допомогою бібліотек, таких як RxJS, через стріми, спостережувані об'єкти, оператори трансформацій. |\n| **Подієво-орієнтоване**        | Використання подій і їх обробників, що є основою браузерного середовища (наприклад, `addEventListener`, `onClick`).                          |\nПримітка:** JavaScript гнучко підтримує кілька парадигм одночасно, що дозволяє використовувати найзручніший підхід для конкретного завдання.",
    "codeExample": "",
    "category": "objects",
    "isFavorite": false
  },
  {
    "id": "90",
    "question": "90. Типи помилок у JavaScript?",
    "answer": "Типи помилок у JavaScript\nУ JavaScript існує кілька типів помилок, які можуть виникати під час виконання коду:\n| **Тип помилки**    | **Опис**                                                                                             | **Приклад**                                                                        |\n| ------------------ | ---------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------- |\n| **SyntaxError**    | Виникає, коли код містить синтаксичну помилку, яка унеможливлює виконання.                           | `javascriptconsole.log(\"Привіт); // SyntaxError: missing \" after argument` |\n| **ReferenceError** | Виникає, коли код звертається до змінної, яка не оголошена.                                          | `javascriptconsole.log(x); // ReferenceError: x is not defined`            |\n| **TypeError**      | Виникає, коли виконується операція над значенням некоректного типу.                                  | `javascriptnull.toString(); // TypeError: Cannot read properties of null`  |\n| **RangeError**     | Виникає, коли значення виходить за допустимі межі.                                                   | `javascriptlet arr = new Array(-1); // RangeError: Invalid array length`   |\n| **EvalError**      | Пов'язана з некоректним використанням функції `eval`. У сучасному JavaScript використовується рідко. | `javascripteval(\"let a = ;\"); // EvalError: Unexpected end of input`       |\n| **URIError**       | Виникає, коли некоректно використовується функція для роботи з URI (наприклад, `decodeURI`).         | `javascriptdecodeURI(\"%\"); // URIError: URI malformed`                     |\nЯк обробляти помилки?\nДля обробки помилок використовується конструкція `try...catch`:",
    "codeExample": "try {\n  const result = JSON.parse(\"Некоректний JSON\");\n} catch (error) {\n  console.error(\"Сталася помилка:\", error.message);\n}",
    "category": "arrays",
    "isFavorite": false
  },
  {
    "id": "91",
    "question": "91. Різниця між typeof і instanceof?",
    "answer": "Різниця між `typeof` і `instanceof`\n| **Критерій**           | **typeof**                                                           | **instanceof**                                                               |\n| ---------------------- | -------------------------------------------------------------------- | ---------------------------------------------------------------------------- |\n| **Призначення**        | Повертає тип змінної як рядок.                                       | Перевіряє, чи є об'єкт екземпляром певного класу або конструктора.           |\n| **Результат**          | Повертає один із базових типів (`string`, `number`, `object`, тощо). | Повертає `true` або `false`.                                                 |\n| **Сфера застосування** | Використовується для визначення типу даних.                          | Використовується для перевірки приналежності об'єкта до класу або прототипу. |\n| **Обмеження**          | Не відрізняє масиви від об'єктів (`typeof []` повертає `object`).    | Працює тільки з об'єктами, створеними через функції-конструктори.            |\nПриклади\ntypeof\ninstanceof\n```javascript\nconst arr = [];\nconsole.log(arr instanceof Array); // true\nconsole.log(arr instanceof Object); // true (Array наслідується від Object)\nconst str = new String(\"Hello\");\nconsole.log(str instanceof String); // true\nconsole.log(str instanceof Object); // true\nconsole.log(\"Hello\" instanceof String); // false (рядок — примітив)\n```\nКлючові відмінності:\n**Примітиви:**\n`typeof` працює з примітивними типами.\n`instanceof` завжди повертає `false` для примітивів.\n**Масиви:**\n`typeof []` повертає `\"object\"`.\n`[] instanceof Array` повертає `true`.\n**null і undefined:**\n`typeof null` повертає `\"object\"` (історична помилка в JavaScript).\n`null instanceof Object` повертає `false`.\n`undefined` не має конструктора, тому `instanceof` не використовується.\n  - Використовуйте `typeof` для перевірки типу примітивів і базових типів, а `instanceof` для перевірки класів і об'єктів.",
    "codeExample": "console.log(typeof \"Hello\"); // \"string\"\nconsole.log(typeof 42); // \"number\"\nconsole.log(typeof {}); // \"object\"\nconsole.log(typeof []); // \"object\" (масиви не розрізняються)\nconsole.log(typeof null); // \"object\" (історична помилка)\nconsole.log(typeof undefined); // \"undefined\"",
    "category": "arrays",
    "isFavorite": false
  },
  {
    "id": "92",
    "question": "92. JavaScript статично, чи динамічно типізована мова?",
    "answer": "JavaScript — це **динамічно типізована** мова програмування.\nЩо це означає?\n**Типи змінних визначаються під час виконання:**\n    - Тип змінної може змінюватися залежно від значення, яке їй присвоюють.\n    - При оголошенні змінної не потрібно вказувати її тип.\n      \n**Відсутність компіляційної перевірки типів:**\n    - Помилки, пов’язані з типами, виявляються тільки під час виконання, а не на етапі компіляції.\n      ```javascript\n      let num = 42;\n      console.log(num.toUpperCase()); // Runtime Error: num.toUpperCase is not a function\n      ```\n**Автоматичне приведення типів (Type Coercion):**\n    - JavaScript автоматично конвертує значення з одного типу в інший у деяких ситуаціях.\n      ```javascript\n      console.log(\"5\" - 2); // 3 (рядок \"5\" перетворюється в число)\n      console.log(\"5\" + 2); // \"52\" (число 2 конкатенується як рядок)\n      ```\nВисновок:\nJavaScript — динамічно типізована мова, що робить її гнучкою, але може спричинити помилки, пов’язані з типами. Для більшої строгості можна використовувати TypeScript — надбудову над JavaScript, яка додає статичну типізацію.",
    "codeExample": "let value = 42; // Зараз це число (number)\n      value = \"Привіт\"; // Тепер це рядок (string)\n      value = true; // Тепер це булеве значення (boolean)",
    "category": "functions",
    "isFavorite": false
  },
  {
    "id": "93",
    "question": "93. Що таке регулярне вираження (Regular Expression)?",
    "answer": "Регулярне вираження (або **Regex**) — це шаблон, який використовується для пошуку, співставлення та маніпуляції тексту в рядках.\nОсновні можливості:\n**Пошук тексту**:\n   - Виявлення підрядків, які відповідають заданому шаблону.\n**Замінювання тексту**:\n   - Заміна тексту, який відповідає регулярному вираженню, на інший текст.\n**Перевірка відповідності**:\n   - Перевірка, чи відповідає текст певному шаблону.\nПриклад регулярного вираження:\n| **Символ** | **Опис**                                   | **Приклад**               |\n| ---------- | ------------------------------------------ | ------------------------- |\n| `.`        | Будь-який символ, крім нового рядка        | `/h.llo/` → \"hello\"       |\n| `^`        | Початок рядка                              | `/^Hello/` → \"Hello\"      |\n| `$`        | Кінець рядка                               | `/world$/` → \"world\"      |\n| `*`        | 0 або більше повторень                     | `/ab*c/` → \"ac\", \"abc\"    |\n| `+`        | 1 або більше повторень                     | `/ab+c/` → \"abc\", \"abbc\"  |\n| `?`        | 0 або 1 повторення                         | `/colou?r/` → \"color\"     |\n| `{n}`      | Точно n повторень                          | `/a{3}/` → \"aaa\"          |\n| `{n,}`     | Не менше n повторень                       | `/a{2,}/` → \"aaa\", \"aaaa\" |\n| `{n,m}`    | Від n до m повторень                       | `/a{2,4}/` → \"aaa\", \"aa\"  |\n| `[abc]`    | Будь-який символ з набору                  | `/[aeiou]/` → \"a\"         |\n| `[^abc]`   | Будь-який символ, крім вказаних            | `/[^aeiou]/` → \"b\"        |\n| `\\d`       | Будь-яка цифра (0–9)                       | `/\\d/` → \"5\"              |\n| `\\D`       | Будь-який нецифровий символ                | `/\\D/` → \"A\"              |\n| `\\w`       | Будь-який алфавітно-цифровий символ або \\_ | `/\\w/` → \"A\", \"1\"         |\n| `\\W`       | Будь-який неалфавітно-цифровий символ      | `/\\W/` → \"@\"              |\n| `\\s`       | Пробільний символ                          | `/\\s/` → \" \"              |\n| `\\S`       | Будь-який непробільний символ              | `/\\S/` → \"A\"              |\n| `(x\\|y)`   | Або x, або y                               | `/(cat\\|dog)/` → \"cat\"    |\nМетоди роботи з Regex у JavaScript:\n`test()`: Перевіряє відповідність шаблону.\n```javascript\nconst regex = /world/;\nconsole.log(regex.test(\"hello world\")); // true\n```\n`match()`: Знаходить співпадіння.\n```javascript\nconst text = \"hello world\";\nconsole.log(text.match(/world/)); // [\"world\"]\n```\n`replace()`: Замінює текст.\n```javascript\nconst text = \"hello world\";\nconsole.log(text.replace(/world/, \"JavaScript\")); // \"hello JavaScript\"\n```\n`split()`: Розбиває рядок за шаблоном.\n```javascript\nconst text = \"apple, banana, cherry\";\nconsole.log(text.split(/,\\s\\*/)); // [\"apple\", \"banana\", \"cherry\"]\n```\nПриклади використання:\nПеревірка email-адреси:\n```javascript\nconst emailRegex = /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$/;\nconsole.log(emailRegex.test(\"example@mail.com\")); // true\n```\nВитяг номерів телефону:\n```javascript\nconst text = \"Call me at 123-456-7890 or 987-654-3210.\";\nconst phoneRegex = /\\d{3}-\\d{3}-\\d{4}/g;\nconsole.log(text.match(phoneRegex)); // [\"123-456-7890\", \"987-654-3210\"]\n```\nПошук слів у рядку:\n```javascript\nconst text = \"JavaScript is awesome!\";\nconst wordRegex = /\\bawesome\\b/;\nconsole.log(wordRegex.test(text)); // true\n```\nРегулярні вираження — потужний інструмент для роботи з текстом, але їх слід використовувати обережно, щоб уникнути складних для розуміння шаблонів.",
    "codeExample": "const regex = /hello/;\nconst text = \"hello world\";\n\nconsole.log(regex.test(text)); // true (знайдено \"hello\")\nconsole.log(text.match(regex)); // [\"hello\"] (співпадіння)",
    "category": "arrays",
    "isFavorite": false
  },
  {
    "id": "94",
    "question": "94. Що таке рекурсія?",
    "answer": "Рекурсія — це техніка програмування, при якій функція викликає саму себе. Вона дозволяє вирішувати складні завдання шляхом розбиття їх на простіші підзадачі.\nОсновні компоненти рекурсії:\n**Базовий випадок (Base Case)**:\n   - Умова, яка зупиняє подальші виклики функції.\n   - Без базового випадку функція буде викликати себе нескінченно, що призведе до переповнення стека викликів.\n**Рекурсивний випадок (Recursive Case)**:\n   - Логіка, яка включає виклик функції самою собою із меншими вхідними даними.\nПриклад рекурсивної функції:\nРозрахунок факторіала числа `n!`:\nПереваги рекурсії:\nЛегше реалізувати задачі, що мають ієрархічну або повторювану структуру (наприклад, дерева, графи, пошук).\nНедоліки рекурсії:\nМоже споживати більше пам’яті через створення великої кількості стекових кадрів.\nПри неправильному базовому випадку може спричинити переповнення стека викликів.\nАльтернатива:\nРекурсію часто можна замінити ітерацією для оптимізації пам’яті, але це може зробити код менш читабельним.",
    "codeExample": "function factorial(n) {\n  if (n === 0) {\n    return 1; // Базовий випадок\n  }\n  return n * factorial(n - 1); // Рекурсивний випадок\n}\n\nconsole.log(factorial(5)); // 120",
    "category": "objects",
    "isFavorite": false
  },
  {
    "id": "95",
    "question": "95. Що таке поліфіл (polyfill)?",
    "answer": "Поліфіл (polyfill) — це код (зазвичай у вигляді бібліотеки або функції), який забезпечує підтримку сучасних функцій JavaScript у старих браузерах або середовищах, де ці функції не реалізовані.\nНавіщо потрібен поліфіл?\nГарантує, що код буде працювати у старіших браузерах, які не підтримують нові можливості ECMAScript.\nЗабезпечує зворотну сумісність для сучасного функціоналу.\nПриклад поліфіла для `Array.prototype.includes`:\nУ браузерах, які не підтримують метод `includes`, можна використовувати поліфіл:\nПереваги поліфіла:\nДозволяє використовувати сучасний синтаксис і функції без втрати сумісності з застарілими середовищами.\nОбмеження:\nПоліфіли збільшують розмір вашого коду.\nВони не завжди забезпечують ідентичну продуктивність, порівняно з нативною реалізацією.\nАльтернатива поліфілам:\nВикористання транспайлерів (наприклад, Babel), які перетворюють сучасний JavaScript у старішу версію.",
    "codeExample": "if (!Array.prototype.includes) {\n  Array.prototype.includes = function (valueToFind, fromIndex) {\n    if (this == null) {\n      throw new TypeError('\"this\" is null or not defined');\n    }\n    const o = Object(this);\n    const len = o.length &gt;&gt;&gt; 0;\n    if (len === 0) {\n      return false;\n    }\n    const n = fromIndex | 0;\n    let k = Math.max(n &gt;= 0 ? n : len - Math.abs(n), 0);\n    while (k &lt; len) {\n      if (\n        o[k] === valueToFind ||\n        (valueToFind !== valueToFind &amp;&amp; o[k] !== o[k])\n      ) {\n        return true;\n      }\n      k++;\n    }\n    return false;\n  };\n}",
    "category": "arrays",
    "isFavorite": false
  },
  {
    "id": "96",
    "question": "96. Що таке switch/case? Правила використання switch/case?",
    "answer": "`switch/case` — це інструкція умовного виконання в JavaScript, яка дозволяє вибирати одну з багатьох можливих гілок коду для виконання на основі значення виразу.\nСинтаксис:\nЯк працює `switch/case`:\nВираз у дужках (`expression`) обчислюється один раз.\nЗначення цього виразу порівнюється зі значеннями в кожному case.\nЯкщо знайдено співпадіння, виконується відповідний блок коду.\nЯкщо співпадіння немає, виконується блок default (якщо він є).\nІнструкція break завершує виконання блоку і виходить з конструкції `switch`. Без неї виконуються всі наступні case до першого `break`.\nПриклад:\n```javascript\nconst day = 3;\nswitch (day) {\n  case 1:\n    console.log(\"Понеділок\");\n    break;\n  case 2:\n    console.log(\"Вівторок\");\n    break;\n  case 3:\n    console.log(\"Середа\");\n    break;\n  default:\n    console.log(\"Невірний день\");\n}\n```\nВиведе: Середа\nПравила використання `switch/case`:\nСтрога рівність (`===`): Порівняння в `switch` використовує оператор строгої рівності. Типи даних мають збігатися.\nВикористання `break`: Завжди додавайте `break`, щоб уникнути виконання всіх наступних гілок.\nПорядок має значення: Перший case, що відповідає умовам, буде виконаний.\nБлок `default`: Використовуйте `default` для обробки ситуацій, коли жоден case не підходить.\nКластеризація case: Якщо декілька case виконують однаковий код, їх можна групувати:\n```javascript\nconst fruit = \"apple\";\nswitch (fruit) {\n  case \"apple\":\n  case \"pear\":\n    console.log(\"Це фрукт із насінням\");\n    break;\n  case \"banana\":\n    console.log(\"Це ягода\");\n    break;\n  default:\n    console.log(\"Невідомий фрукт\");\n}\n```\nКоли використовувати `switch/case`:\nКоли потрібно перевірити значення змінної на кілька можливих значень.\nКоли вирази в case прості й не вимагають складних умов.\nОбмеження:\nНе підтримує діапазони або складні умови.\nМоже бути менш читабельним, ніж `if/else` для коротких умов.",
    "codeExample": "switch (expression) {\n  case value1:\n    // Код для виконання, якщо expression === value1\n    break;\n  case value2:\n    // Код для виконання, якщо expression === value2\n    break;\n  default:\n  // Код для виконання, якщо жоден із case не спрацював\n}",
    "category": "other",
    "isFavorite": false
  },
  {
    "id": "97",
    "question": "97. Типи функцій щодо можливості приймати інші функції?",
    "answer": "У JavaScript функції можуть бути класифіковані на основі того, чи вони приймають інші функції як аргументи, або повертають їх.\n**Функція вищого порядку (Higher-Order Function)**\nФункція, яка може:\n  - Приймати інші функції як аргументи.\n  - Повертає інші функції.\nПриклад:\n**Колбек-функція (Callback Function)**\nФункція, яка передається як аргумент іншій функції та викликається всередині цієї функції.\nПриклад:\n```javascript\nfunction greet(name, callback) {\n  console.log(`Привіт, ${name}!`);\n  callback();\n}\ngreet(\"Еван\", () =&gt; console.log(\"Це колбек-функція!\"));\n// Виведе:\n// Привіт, Еван!\n// Це колбек-функція!\n```\n**Анонімна функція (Anonymous Function)**\nФункція без імені, яка зазвичай передається як колбек.\nПриклад:\n```javascript\nsetTimeout(() =&gt; {\n  console.log(\"Анонімна функція викликана через 1 секунду!\");\n}, 1000);\n```\n**Функція-замикання (Closure)**\nФункція, яка зберігає доступ до змінних із зовнішнього лексичного контексту навіть після завершення виконання зовнішньої функції.\nПриклад:\n```javascript\nfunction closureExample() {\n  let count = 0;\n  return function () {\n    count++;\n    return count;\n  };\n}\nconst counter = closureExample();\nconsole.log(counter()); // 1\nconsole.log(counter()); // 2\n```\nВисновок:\n**_Функції вищого порядку_** використовуються для створення динамічних і функціональних підходів у програмуванні.\n**_Колбеки_** дозволяють передавати поведінку як аргумент.\n**_Анонімні функції_** підходять для одноразового використання.\n**_Замикання_** дозволяють зберігати стан у функціях.",
    "codeExample": "// Функція, яка приймає іншу функцію як аргумент\nfunction higherOrderFunction(callback) {\n  callback();\n}\n\n// Функція, яка повертає іншу функцію\nfunction createMultiplier(multiplier) {\n  return function (value) {\n    return value * multiplier;\n  };\n}\n\n// Використання\nhigherOrderFunction(() =&gt; console.log(\"Привіт із колбека!\")); // Виклик колбеку\nconst double = createMultiplier(2);\nconsole.log(double(5)); // 10",
    "category": "functions",
    "isFavorite": false
  },
  {
    "id": "98",
    "question": "98. Що таке вирази (expression) та інструкції (statement) у JavaScript?",
    "answer": "Вирази (Expression) та Інструкції (Statement) у JavaScript\nВирази (Expression)\n**Вираз** — це будь-яка одиниця коду, яка обчислюється та повертає значення.  \n  Вирази можуть бути частиною інструкцій.\nПриклади виразів:\nОсобливості:\nЗавжди повертають значення.\nМожуть використовуватись у контексті:\n   - Присвоєння (let result = 5 + 3;).\n   - Умови (if (x &gt; 0)).\n   - Аргументи для функцій (console.log(x + y)).\nІнструкції (Statement)\n**Інструкція** — це повноцінний фрагмент коду, що виконує дію, але не обов’язково повертає значення.\nІнструкції керують виконанням програми.\nПриклади інструкцій:\n```javascript\nlet a = 5; // Інструкція оголошення змінної\nif (a &gt; 0) {\n  // Інструкція умовного виконання\n  console.log(a); // Інструкція виклику функції\n}\n```\nОсобливості:\nВиконують дію (наприклад, оголошення змінної, виклик функції).\nМожуть містити вирази.\nОсновна відмінність\n| Характеристика  | Вираз (Expression)                     | Інструкція (Statement)               |\n| --------------- | -------------------------------------- | ------------------------------------ |\n| **Призначення** | Обчислює та повертає значення.         | Виконує дію.                         |\n| **Приклади**    | `5 + 3`, `\"hello\" + \"world\"`, `x &gt; 0`. | `let x = 10;`, `if (x &gt; 0) { ... }`. |\n| **Вкладеність** | Може бути частиною інструкції.         | Може містити вирази.                 |\n| **Результат**   | Завжди повертає значення.              | Може не повертати значення.          |\nКомбінування виразів та інструкцій:\n```javascript\nlet x = 10; // Інструкція (оголошення змінної)\nlet result = x * 2; // Інструкція з виразом (x * 2)\nif (result &gt; 10) {\n  // Інструкція умовного виконання\n  console.log(result); // Інструкція виклику функції\n}\n```\nУ цьому прикладі:\n  - `x * 2` — вираз.\n  - `let result = x * 2;` — інструкція.",
    "codeExample": "// Вирази, що повертають значення\n5 + 3; // Додає 5 і 3, результат: 8\n\"x\" + \"y\"; // Конкатенація, результат: \"xy\"\nMath.max(10, 20); // Визначення максимального числа, результат: 20",
    "category": "functions",
    "isFavorite": false
  },
  {
    "id": "99",
    "question": "99. Різниця між .some() та .every()?",
    "answer": "Порівняння методів .some() та .every()\n| Метод          | Опис                                                       | Повертає                                                             | Приклад                                |\n| -------------- | ---------------------------------------------------------- | -------------------------------------------------------------------- | -------------------------------------- |\n| **`.some()`**  | Перевіряє, чи хоча б один елемент масиву відповідає умові. | `true`, якщо хоча б один елемент відповідає умові. Інакше — `false`. | `[1, 2, 3].some(x =&gt; x &gt; 2)` → `true`  |\n| **`.every()`** | Перевіряє, чи всі елементи масиву відповідають умові.      | `true`, якщо всі елементи відповідають умові. Інакше — `false`.      | `[1, 2, 3].every(x =&gt; x &gt; 0)` → `true` |\nОсновні відмінності:\n**`.some()`** зупиняється після знаходження першого відповідного елемента.\n**`.every()`** зупиняється після знаходження першого невідповідного елемента.",
    "codeExample": "",
    "category": "arrays",
    "isFavorite": false
  },
  {
    "id": "100",
    "question": "100. Як згенерувати випадкове число у JavaScript?",
    "answer": "За допомогою використання `Math.random()`\nМетод `Math.random()` повертає випадкове число в діапазоні від `0` (включно) до `1` (не включно).\nПриклади:\n**Випадкове число від `0` до `1`:**\n**Випадкове число в діапазоні від `0` до `10`:**\n```javascript\nconst random = Math.random() * 10;\nconsole.log(random); // Наприклад: 7.89432\n```\n**Ціле число в діапазоні від `0` до `10`:**\n```javascript\nconst randomInt = Math.floor(Math.random() * 11); // Включно 0 та 10\nconsole.log(randomInt); // Наприклад: 3\n```\n**Випадкове число в заданому діапазоні (`min`, `max`):**\n```javascript\nfunction getRandomInRange(min, max) {\nreturn Math.random() \\* (max - min) + min;\n}\nconsole.log(getRandomInRange(5, 15)); // Наприклад: 7.23\n```\n**Ціле число в заданому діапазоні (`min`, `max`):**\n```javascript\nfunction getRandomIntInRange(min, max) {\nreturn Math.floor(Math.random() _ (max - min + 1)) + min;\n}\nconsole.log(getRandomIntInRange(5, 15)); // Наприклад: 12\n```\nПояснення:\nMath.random() генерує дробове число в діапазоні `[0, 1)`.\nДля масштабування використовується множення `(* max)`.\nДля округлення до цілого числа застосовується `Math.floor()` або `Math.round()`.\nДля зміщення мінімального значення додається `+ min`.",
    "codeExample": "const random = Math.random();\nconsole.log(random); // Наприклад: 0.123456789",
    "category": "objects",
    "isFavorite": false
  },
  {
    "id": "101",
    "question": "101. Типи операторів у JavaScript?",
    "answer": "Типи операторів у JavaScript\nОператори в JavaScript використовуються для виконання різних операцій, таких як арифметичні обчислення, порівняння, присвоєння тощо.\nОсновні типи операторів:\n**Арифметичні оператори**\n   - Використовуються для виконання математичних операцій:\n   - `+, -, *, /, % (залишок від ділення)`, `**` (піднесення до степеня).\n**Оператори присвоєння**\n   - Використовуються для присвоєння значень змінним:\n   - `=`, `+=`, `-=`, `*=`, `/=`, `%=`.\n**Оператори порівняння**\n   - Використовуються для порівняння значень і повертають true або false:\n   - `==`, `!=`, `===`, `!==`, `&lt;`, `&gt;`, `&lt;=`, `&gt;=`.\n**Логічні оператори**\n   - Використовуються для логічних операцій:\n   - `&amp;&amp;` (і), `||` (або), `!` (заперечення).\n**Тернарний оператор**\n   - Скорочений запис для умовних операторів:\n   - `condition ? expr1 : expr2`.\n**Бітові оператори**\n   - Працюють на рівні бітів чисел:\n   - `&amp;`, `|`, `^`, `~`, `&lt;&lt;`, `&gt;&gt;`, `&gt;&gt;&gt;`.\n**Оператори типу (Type)**\n   - Використовуються для перевірки або конверсії типу значення:\n   - `typeof`, `instanceof`.\n**Оператори рядків**\n   - Використовуються для маніпуляції рядками:\n   - `+` (конкатенація), `+=` (додавання до рядка).\n**Оператори доступу**\n   - Використовуються для доступу до властивостей або методів об'єктів:\n   - `obj.property`, `obj[\"property\"]`.\n**Оператори розділення (spread/rest)**\n    - Використовуються для роботи з масивами або об'єктами:\n    - `...`\n**Оператори виклику**\n    - Використовуються для виклику функцій:\n    - `func()`, `obj.method()`.\n**Оператори nullish**\n    - Використовуються для перевірки на null або undefined:\n    - `??`.\n**Опціональний ланцюжок**\n    - Перевіряє існування властивостей перед доступом до них:\n    - `obj?.property`, `obj?.method()`.",
    "codeExample": "",
    "category": "arrays",
    "isFavorite": false
  },
  {
    "id": "102",
    "question": "102. Яка різниця між параметром та аргументом функції?",
    "answer": "Різниця:\n**_Параметр_** — це змінна, яка вказана у визначенні функції. Це місце для отримання значення.\n**_Аргумент_** — це фактичне значення, яке передається функції під час її виклику.\nПриклад:",
    "codeExample": "function add(a, b) {\n  // a, b — параметри\n  return a + b;\n}\n\nadd(2, 3); // 2, 3 — аргументи",
    "category": "functions",
    "isFavorite": false
  },
  {
    "id": "103",
    "question": "103. Правила завдання імен для змінних та функцій JavaScript?",
    "answer": "Іменування змінних:\nІм'я може починатися з літери, знака підкреслення `(_)` або долара `($)`, але не з цифри.\nДалі можуть використовуватись літери, цифри, підкреслення `(_)` або долар `($)`.\nНе можна використовувати зарезервовані слова (наприклад, `class`, `return`).\nІмена чутливі до регістру (`varName` ≠ `VarName`).\nДля змінних використовують `camelCase`.\nДля функцій також рекомендовано `camelCase`.\nІмена повинні бути осмисленими та описовими.",
    "codeExample": "",
    "category": "functions",
    "isFavorite": false
  },
  {
    "id": "104",
    "question": "104. Різниця між явним та неявним перетворенням (Implicit and Explicit Coercion)?",
    "answer": "Implicit and Explicit Coercion\n**Явне перетворення (Explicit Coercion):**\n  - Розробник явно вказує, як і в що перетворити значення, використовуючи методи або оператори.\nПриклади:\n**Неявне перетворення (Implicit Coercion):**\n  - JavaScript автоматично змінює типи в залежності від контексту.\nПриклади:\n```javascript\n+ \"abc\"; // \"123abc\" (число перетворено в рядок)\n\"5\" - 1; // 4 (рядок перетворено в число)\n!\"\"; // true (рядок перетворено в логічний тип)\n```\n**_Різниця:_** явне перетворення контрольоване, неявне може призводити до непередбачуваних результатів.",
    "codeExample": "String(123); // \"123\"\nNumber(\"456\"); // 456\nBoolean(0); // false",
    "category": "other",
    "isFavorite": false
  },
  {
    "id": "105",
    "question": "105. Навіщо застосовується метод Array.from()?",
    "answer": "Array.from() створює новий масив із:\n**Масивоподібних об’єктів:** об’єкти з властивістю length (наприклад, arguments або NodeList).\n**Ітерабельних об'єктів:** об’єкти, які можна ітерувати (Map, Set, строки тощо).\n```javascript\nconst set = new Set([1, 2, 3]);\nconst array = Array.from(set); // [1, 2, 3]\n```\n**З трансформацією:** другий аргумент — callback-функція для перетворення елементів.\n```javascript\nconst array = Array.from([1, 2, 3], (x) =&gt; x * 2); // [2, 4, 6]\n```\n**_Призначення:_** зручне створення масивів із нестандартних джерел даних або трансформація елементів.",
    "codeExample": "const nodeList = document.querySelectorAll(\"div\");\nconst array = Array.from(nodeList); // Перетворює NodeList у масив",
    "category": "arrays",
    "isFavorite": false
  },
  {
    "id": "106",
    "question": "106. Назвіть способи перетворення масиву на об'єкт?",
    "answer": "Способи перетворення:\n**`Object.assign()`:**\nКопіює масив у новий об'єкт, де індекси масиву стають ключами.\n**Ручне ітерування:**\nПроходите по масиву й додаєте ключі вручну.\n```javascript\nconst arr = [1, 2, 3];\nconst obj = {};\narr.forEach((value, index) =&gt; {\n  obj[index] = value;\n});\n// {0: 1, 1: 2, 2: 3}\n```\n**`reduce()`:**\nСтворює об'єкт, накопичуючи ключі та значення.\n```javascript\nconst arr = [\"a\", \"b\", \"c\"];\nconst obj = arr.reduce((acc, value, index) =&gt; {\n  acc[index] = value;\n  return acc;\n}, {});\n// {0: 'a', 1: 'b', 2: 'c'}\n```\n**`Object.fromEntries()`:**\nПеретворює масив пар [key, value] на об'єкт.\n```javascript\nconst arr = [\n  [\"key1\", \"value1\"],\n  [\"key2\", \"value2\"],\n];\nconst obj = Object.fromEntries(arr); // {key1: 'value1', key2: 'value2'}\n```\n**Spread оператор з деструктуризацією:**\nПеретворення в об'єкт із зазначенням ключів.\n```javascript\nconst arr = [1, 2, 3];\nconst obj = { ...arr }; // {0: 1, 1: 2, 2: 3}\n```",
    "codeExample": "const arr = [1, 2, 3];\nconst obj = Object.assign({}, arr); // {0: 1, 1: 2, 2: 3}",
    "category": "arrays",
    "isFavorite": false
  },
  {
    "id": "107",
    "question": "107. Різниця між Object та Map?",
    "answer": "Ключові відмінності між Object і Map:\n**Типи ключів:**\n`Object`: ключі можуть бути лише рядками або символами.\n`Map`: ключі можуть бути будь-якого типу (рядки, числа, об’єкти тощо).\n```javascript\nconst map = new Map();\nmap.set(1, \"value\"); // Ключ залишається числом\n```\n**Порядок зберігання:**\n`Object`: порядок ключів не гарантований (крім певних ситуацій).\n`Map`: зберігає ключі в порядку їх додавання.\n**Продуктивність:**\n`Map`: оптимізований для частого додавання, видалення та пошуку.\n`Object`: повільніше працює з великою кількістю ключів.\n**Ітерація:**\n`Object`: потрібно використовувати `Object.keys()`, `Object.values()`, або `Object.entries()`.\n`Map`: ітерації простіші, є методи `map.keys()`, `map.values()`, `map.entries()`.\n**Розмір:**\n`Object`: немає прямого способу дізнатися кількість ключів (потрібно використовувати `Object.keys().length`).\n`Map`: має властивість size.\n**Прототип:**\n`Object`: має прототип із вбудованими методами, що може викликати конфлікти з ключами.\n`Map`: не має прототипу, ключі не конфліктують.\n**Коли використовувати:**\n`Object`: для структурованих даних (наприклад, конфігурації, `JSON`).\n`Map`: для частих операцій із ключами/значеннями або коли потрібна підтримка будь-яких типів ключів.",
    "codeExample": "const obj = {};\nobj[1] = \"value\"; // Ключ '1' перетворюється на рядок",
    "category": "arrays",
    "isFavorite": false
  },
  {
    "id": "108",
    "question": "108. Що таке карірування (currying)?",
    "answer": "currying\nКарірування (currying) — це техніка функціонального програмування, коли функція з кількома аргументами перетворюється на послідовність функцій, кожна з яких приймає один аргумент.\nПриклад:\nОригінальна функція:\nКарірована версія:\n```javascript\nfunction curriedAdd(a) {\n  return function (b) {\n    return a + b;\n  };\n}\ncurriedAdd(2)(3); // 5\n```\nПереваги:\nГнучкість: дозволяє створювати частково застосовані функції.\n```javascript\nconst add5 = curriedAdd(5);\nconsole.log(add5(10)); // 15\n```\n**_Читабельність та повторне використання:_** спрощує складні обчислення, зберігаючи модульність.\n**_Композиція:_** добре працює з іншими функціональними методами.\nКарірування з використанням ES6:\n```javascript\nconst curriedMultiply = (a) =&gt; (b) =&gt; a * b;\nconsole.log(curriedMultiply(4)(5)); // 20\n```\n**Карірування** — зручний інструмент для функціонального стилю програмування, особливо в роботі з композицією функцій.",
    "codeExample": "function add(a, b) {\n  return a + b;\n}\nadd(2, 3); // 5",
    "category": "functions",
    "isFavorite": false
  },
  {
    "id": "109",
    "question": "109. Навіщо використовують метод Object.seal()?",
    "answer": "`Object.seal()` використовується для обмеження змін у об'єкті.\n**_Особливості:_**\n**Заборона додавання або видалення властивостей:**\n   - Ви не можете додати нові властивості чи видалити існуючі.\n**Зміна значень дозволена:**\n   - Ви можете змінювати значення існуючих властивостей.\n```javascript\nobj.a = 10; // Працює\n```\n**Статус sealed:**\n   - Метод `Object.isSealed()` дозволяє перевірити, чи об'єкт запечатано.\n```javascript\nconsole.log(Object.isSealed(obj)); // true\n```\n**Не дозволяє змінювати конфігурацію властивостей:**\n   - Наприклад, ви не можете змінити `writable`, `configurable` чи `enumerable`.\nВикористання:\nЗахист структури об'єкта, дозволяючи лише змінювати значення.\nЗменшення помилок через випадкові зміни структури.",
    "codeExample": "const obj = { a: 1 };\nObject.seal(obj);\nobj.b = 2; // Нічого не станеться (додавання заборонено)\ndelete obj.a; // Нічого не станеться (видалення заборонено)",
    "category": "objects",
    "isFavorite": false
  },
  {
    "id": "110",
    "question": "110. Навіщо використовується властивість .dataset?",
    "answer": ".dataset\n`dataset` використовується для доступу до спеціальних атрибутів HTML, які починаються з `data-`. Це зручний спосіб зберігати кастомні дані в елементах DOM.\nОсобливості:\n**Доступ до даних:**\nЧерез dataset можна отримати або змінити значення атрибутів data- як властивостей об'єкта.\n```javascript\nconst elem = document.getElementById(\"element\");\nconsole.log(elem.dataset.id); // \"123\"\nconsole.log(elem.dataset.name); // \"example\"\n```\n**Створення та оновлення:**\n```javascript\nelem.dataset.newAttr = \"value\"; // Додає data-new-attr=\"value\"\nelem.dataset.id = \"456\"; // Оновлює data-id=\"456\"\n```\n**Іменування:**\nКебаб-кейс у HTML (`data-user-id`) перетворюється в camelCase у JavaScript (`dataset.userId`).\n**Видалення:**\n```javascript\ndelete elem.dataset.newAttr; // Видаляє data-new-attr\n```\nПереваги:\nІнкапсуляція даних, пов'язаних із елементом, без необхідності створення окремих JavaScript-змінних.\nЗручно використовувати для динамічної взаємодії елементів із JavaScript, наприклад, у додатках або при роботі з атрибутами.\nПриклад використання:\n```html\nSave\n```\n```javascript\nconst button = document.querySelector(\"button\");\nconsole.log(button.dataset.action); // \"save\"\nconsole.log(button.dataset.userId); // \"42\"\n```",
    "codeExample": "html\n<div id=\"element\" data-id=\"123\" data-name=\"example\"></div>",
    "category": "objects",
    "isFavorite": false
  },
  {
    "id": "111",
    "question": "111. Як можна обмінюватися кодом між файлами?",
    "answer": "Обмін кодом між файлами в JavaScript здійснюється через механізми модулів.\n**Основні способи:**\n**_ES Modules (ECMAScript Modules):_**\nСучасний стандарт для імпорту/експорту коду.\n**Експорт:**\n**Імпорт:**\n```javascript\n// main.js\nimport { add, subtract } from \"./math.js\";\nconsole.log(add(2, 3)); // 5\n```\n**Експорт за замовчуванням:**\n```javascript\nexport default function multiply(a, b) { return a \\* b; }\n// Імпорт\nimport multiply from './math.js';\nconsole.log(multiply(2, 3)); // 6\n```\n**_CommonJS (Node.js):_**\nВикористовується в середовищі `Node.js`.\n**Експорт:**\n```javascript\n// math.js\nmodule.exports = {\n  add: (a, b) =&gt; a + b,\n  subtract: (a, b) =&gt; a - b,\n};\n```\n**Імпорт:**\n```javascript\n// main.js\nconst math = require(\"./math\");\nconsole.log(math.add(2, 3)); // 5\n```\n**_Скрипти через глобальні змінні (застарілий метод):_**\nПідключення файлів у HTML із використанням ``:\n```html\n```\nНедолік: все потрапляє в глобальний простір.\n**_Бандлери (Webpack, Rollup, Vite):_**\nДля складних проектів використовуються бандлери, які об'єднують файли. Вони підтримують `ES Modules` і `CommonJS`.\n**_JSON файли:_**\n`JSON` можна імпортувати напряму як модуль.\n```javascript\n// data.json\n{ \"name\": \"John\", \"age\": 30 }\n// main.js\nimport data from './data.json';\nconsole.log(data.name); // \"John\"\n```\nРекомендація:\nДля сучасних веб-додатків використовуйте `ES Modules`. Для `Node.js` — `CommonJS` або `ES Modules` (залежно від конфігурації).",
    "codeExample": "// math.js\nexport const add = (a, b) =&gt; a + b;\nexport const subtract = (a, b) =&gt; a - b;",
    "category": "objects",
    "isFavorite": false
  },
  {
    "id": "112",
    "question": "112. Як працює «складальник сміття» в JavaScript?",
    "answer": "Garbage Collector\n**Складальник сміття (Garbage Collector, GC)** в JavaScript автоматично керує пам'яттю, звільняючи непотрібні об'єкти, до яких немає посилань. Це дозволяє розробникам не турбуватися про ручне управління пам'яттю.\nПринцип роботи:\n**Розподіл пам'яті:**\nКоли створюються змінні, об'єкти, масиви тощо, для них виділяється пам'ять у `heap` (куча).\n**Виявлення недосяжних об'єктів:**\nGC знаходить об'єкти, які більше не використовуються, тобто до яких немає посилань, і помічає їх для видалення.\n**Звільнення пам'яті:**\nПомічені об'єкти видаляються, а пам'ять звільняється для повторного використання.\nОсновний алгоритм:\nJavaScript зазвичай використовує алгоритм маркування та очищення (`Mark-and-Sweep`):\n  - **Маркування:** GC починає з \"коренів\" (глобальні об'єкти, наприклад, window в браузері) і перевіряє, які об'єкти досяжні.\n  - **Очищення:** Непомічені об'єкти (ті, до яких немає посилань) видаляються.\nПриклади:\n**Досяжні об'єкти:**\n**Циклічні посилання (не проблема для сучасного GC):**\n```javascript\nlet a = {};\nlet b = {};\na.ref = b;\nb.ref = a;\na = null;\nb = null; // Обидва об'єкти стануть недосяжними\n```\nТипи пам'яті:\n**Stack:** Зберігає примітивні типи та посилання на об'єкти.\n**Heap:** Використовується для зберігання об'єктів і складних структур.\nОптимізація роботи з пам'яттю:\nУникайте створення зайвих глобальних змінних.\nЗакривайте посилання на об'єкти, які більше не потрібні (`null` або `undefined`).\nБудьте обережні з замиканнями: Не зберігайте зайві змінні в пам'яті.\n```javascript\nfunction createClosure() {\n  let largeData = new Array(1000000);\n  return function () {\n    console.log(\"Closure used\");\n  };\n}\nconst closure = createClosure();\n// largeData досі у пам'яті, поки closure існує\n```\nGC працює у фоновому режимі, але при неефективному використанні пам'яті можливі \"зависання\" програми.",
    "codeExample": "let obj = { name: \"John\" };\n// obj має посилання, GC не видалить\nobj = null; // Тепер об'єкт можна очистити",
    "category": "arrays",
    "isFavorite": false
  },
  {
    "id": "113",
    "question": "113. Що таке витоки пам'яті?",
    "answer": "Memory Leaks\n**Витоки пам'яті (Memory Leaks)** — це ситуація, коли програма займає пам'ять, але більше не використовує її, і ця пам'ять не звільняється, бо на неї все ще існують посилання. У JavaScript витоки пам'яті можуть призводити до погіршення продуктивності програми або навіть до її аварійного завершення.\nОсновні причини витоків пам'яті:\n**Невидалені глобальні змінні:**\nЗмінні, оголошені без let, const, або var, автоматично стають глобальними. Глобальні змінні залишаються в пам'яті протягом усього життя програми.\n**Зайві замикання (closures):**\nЗамикання можуть утримувати посилання на змінні, навіть якщо вони більше не потрібні.\n```javascript\nfunction createLeak() {\n  let largeData = new Array(1000000); // Великий масив\n  return function () {\n    console.log(largeData);\n  };\n}\nconst leak = createLeak();\n```\n**Застарілі об'єкти в структурах даних:**\nОб'єкти, які більше не потрібні, але залишаються у масивах або `Map/Set`.\n```javascript\nlet cache = new Map();\nfunction addToCache(key, value) {\n  cache.set(key, value);\n}\naddToCache(\"user\", { name: \"John\" }); // Не видалено\n```\n**Детачені (від'єднані) DOM-елементи:**\nDOM-елементи, які видалені з документа, але на них залишаються посилання.\n```javascript\nlet element = document.getElementById(\"leak\");\nelement.remove();\n// element все ще у пам'яті через посилання\n```\n**Інтервали та таймери:**\nТаймери (`setInterval` або `setTimeout`) утримують посилання на функції, які можуть посилатися на великі дані.\n```javascript\nlet interval = setInterval(() =&gt; {\n  console.log(\"Leaking...\");\n}, 1000);\n// Забули викликати clearInterval(interval);\n```\nЯк уникати витоків пам'яті:\n**Звільняйте пам'ять:**\nОчищайте змінні (`null` або `undefined`) після використання.\nВикористовуйте delete для властивостей об'єкта, якщо вони більше не потрібні.\nКонтролюйте глобальні змінні:\nУникайте використання глобальних змінних, працюйте у локальному контексті.\nОчищайте DOM:\nПісля видалення DOM-елементів видаляйте всі посилання на них.\n```javascript\nelement = null;\n```\nЗакривайте інтервали та таймери:\nВикористовуйте `clearInterval` і `clearTimeout`.\nСлабкі посилання:\nВикористовуйте `WeakMap` або `WeakSet` для даних, які можуть автоматично видалятися, якщо на них немає інших посилань.\nДіагностика:\nДля виявлення витоків пам'яті використовуйте `DevTools` у браузерах:\n  - **Memory tab:** аналізуйте heap snapshots.\n  - **Performance tab:** аналізуйте час та споживання ресурсів.",
    "codeExample": "function leak() {\n  globalVar = \"I am a leak\"; // Глобальна змінна\n}\nleak();",
    "category": "arrays",
    "isFavorite": false
  },
  {
    "id": "114",
    "question": "114. Як працює контекст виконання (execution context) у JavaScript?",
    "answer": "Execution context\nКонтекст виконання — це середовище, де виконується код. Є глобальний, функціональний і контекст модуля.\n**Глобальний контекст:** створюється при запуску скрипта, доступні глобальні змінні та функції. У браузері це `window` або `globalThis`.\n**Функціональний контекст:** створюється під час виклику функції, включає локальні змінні, аргументи й визначає `this`.\n**Модульний контекст:** ізольований від глобального, кожен модуль має свій.\n   Контексти організовані в стек: викликаний останнім контекст виконується першим.\n`this` залежить від способу виклику: у глобальному контексті це window, у методах об’єкта — сам об’єкт, у стрілкових функціях — `this` зовнішнього контексту.\nОсь приклад для демонстрації контексту виконання:\nУ цьому прикладі видно, як this змінюється залежно від способу виклику.",
    "codeExample": "// Глобальний контекст\nconsole.log(this); // У браузері: window\n\nfunction foo() {\n  // Функціональний контекст\n  console.log(this); // У строгому режимі: undefined, без нього: window\n  bar();\n}\n\nfunction bar() {\n  console.log(this); // У строгому режимі: undefined, без нього: window\n}\n\nconst obj = {\n  method() {\n    console.log(this); // obj\n    const inner = () =&gt; {\n      console.log(this); // obj (стрілкова функція успадковує this)\n    };\n    inner();\n  },\n};\n\nfoo(); // Викликаємо функцію в глобальному контексті\nobj.method(); // Викликаємо метод об'єкта",
    "category": "objects",
    "isFavorite": false
  },
  {
    "id": "115",
    "question": "115. Різниця між примітивом та об'єктом?",
    "answer": "Примітиви та об'єкти в JavaScript відрізняються за сутністю, поведінкою та способом зберігання даних.\nПримітиви:\n**Типи:** `string`, `number`, `bigint`, `boolean`, `symbol`, `null`, `undefined`.\n**Незмінність:** Значення примітивів не можна змінити (`immutable`). Наприклад, операції над рядками створюють новий рядок, а не змінюють існуючий.\n**Передача за значенням:** Копіюється саме значення, а не посилання на нього.\n**Властивості:** Можна тимчасово звертатися до властивостей через обгортки (`String`, `Number`), але ці об'єкти створюються й одразу знищуються.\nОб'єкти:\n**Типи:** Усе, що не є примітивом, — це об'єкт (включаючи масиви, функції).\n**Змінність:** Дані в об'єктах можна змінювати (mutable).\n**Передача за посиланням:** Копіюється посилання, а не самі дані.\n**Методи та властивості:** Об'єкти можуть мати свої властивості й методи, які змінюються динамічно.\n```javascript\nlet obj1 = { x: 10 };\nlet obj2 = obj1;\nobj2.x = 20;\nconsole.log(obj1.x); // 20 (змінюється через спільне посилання)\n```\nВисновок:\nПримітиви зберігають значення, об'єкти — посилання. Примітиви незмінні, об'єкти — змінні.",
    "codeExample": "let a = 10;\nlet b = a;\nb = 20;\nconsole.log(a); // 10 (значення `a` не змінюється)",
    "category": "arrays",
    "isFavorite": false
  },
  {
    "id": "116",
    "question": "116. Що означає текст max call stack size exceeded у консолі?",
    "answer": "Maximum call stack size exceeded\nПомилка \"Maximum call stack size exceeded\" виникає, коли стек викликів (call stack) перевантажується через надмірну кількість вкладених викликів функцій. Це зазвичай трапляється через рекурсію без базового випадку або нескінченний цикл викликів функцій.\nПричини:\n**Безмежна рекурсія:**\nТут `recurse` викликає саму себе без завершення.\n**Взаємні виклики функцій:**\n```javascript\nfunction a() {\n  b();\n}\nfunction b() {\n  a();\n}\na(); // Викликає помилку\n```\n**Велика кількість вкладених викликів:** Якщо функція викликається занадто багато разів до завершення попередніх викликів, стек переповнюється.\nЩо таке стек викликів?\nСтек викликів — це структура даних, яка зберігає інформацію про активні функції, що виконуються. Кожен новий виклик додається в стек, і видаляється після завершення.\nЯк виправити:\n**_Перевір рекурсію:_** Завжди додавай базовий випадок.\n```javascript\nfunction recurse(n) {\n  if (n &lt;= 0) return; // Базовий випадок\n  recurse(n - 1);\n}\nrecurse(10);\n```\n**_Обмежуй вкладені виклики._** Використовуй ітерації замість глибокої рекурсії:\n```javascript\nfunction iterate(n) {\n  while (n &gt; 0) {\n    console.log(n);\n    n--;\n  }\n}\niterate(10);\n```\n**_Перевір взаємозалежності функцій._**\nЦя помилка завжди свідчить про логічну проблему у коді, яку потрібно виправити.",
    "codeExample": "function recurse() {\n  recurse();\n}\nrecurse(); // Викликає помилку",
    "category": "functions",
    "isFavorite": false
  },
  {
    "id": "117",
    "question": "117. Як реалізувати відкладене завантаження зображень?",
    "answer": "lazy loading\nВідкладене завантаження зображень (lazy loading) оптимізує завантаження сторінки, завантажуючи зображення лише тоді, коли вони стають видимими в області перегляду.\nМетоди реалізації:\n**_HTML-атрибут `loading=\"lazy\"` (сучасні браузери)_**\n   - Найпростіший спосіб. Додаєш атрибут до тега ``:\nПідтримується більшістю сучасних браузерів.\n**_Intersection Observer API (гнучкий контроль)_**\n   - Використовує JavaScript для виявлення, коли зображення потрапляє в область перегляду:\n```html\n```\n```javascript\ndocument.addEventListener(\"DOMContentLoaded\", () =&gt; {\n  const images = document.querySelectorAll(\"img.lazy\");\n  const observer = new IntersectionObserver((entries, obs) =&gt; {\n    entries.forEach((entry) =&gt; {\n      if (entry.isIntersecting) {\n        const img = entry.target;\n        img.src = img.dataset.src;\n        img.classList.remove(\"lazy\");\n        obs.unobserve(img);\n      }\n    });\n  });\n  images.forEach((img) =&gt; observer.observe(img));\n});\n```\n**_Бібліотеки_**\n   - Готові рішення для зручності:\n     - Lazysizes\n     - Lozad.js\n**_CSS для Placeholders_**\n   - Можна додати стиль для місця, поки зображення не завантажиться:\n```css\nimg.lazy {\n  filter: blur(10px);\n  transition: filter 0.3s;\n}\nimg.lazy:not([src]) {\n  background-color: #f0f0f0;\n}\n```\nЩо врахувати:\nВикористовуй fallback для старих браузерів.\nПереконайся, що `alt`-тексти завжди заповнені для SEO та доступності.\nПеревіряй продуктивність на реальних пристроях.",
    "codeExample": "html\n<img src=\"high-quality-image.jpg\" alt=\"Description\" loading=\"lazy\">",
    "category": "arrays",
    "isFavorite": false
  },
  {
    "id": "118",
    "question": "118. Чим відрізняються події input та change?",
    "answer": "input VS change\n`input` і `change` в JavaScript — це події, які відслідковують зміни в елементах форми, але вони мають різну поведінку.\nПодія `input`:\nСпрацьовує щоразу, коли змінюється значення елемента (під час введення тексту, видалення символів тощо).\nСпрацьовує миттєво, як тільки користувач взаємодіє з елементом.\nПрацює з елементами ``та ``.\n**_Приклад:_**\nВведення кожної літери викликає обробник.\nПодія `change`:\nСпрацьовує тільки після того, як зміна підтверджена, тобто:\n  - Користувач втратив фокус з елемента (`blur`).\n  - Для `&lt;select&gt;` — після вибору нового значення.\nПрацює з `&lt;input&gt;`, `&lt;textarea&gt;`, `&lt;select&gt;`.\n**_Приклад:_**\n```javascript\nconst inputField = document.querySelector(\"#myInput\");\ninputField.addEventListener(\"change\", (event) =&gt; {\n  console.log(\"Final value after focus lost:\", event.target.value);\n});\n```\nОбробник викликається тільки після завершення введення і переходу до іншого елемента.\nКлючові відмінності:\n| **Критерій**              | **input**                 | **change**                          |\n| ------------------------- | ------------------------- | ----------------------------------- |\n| **Коли спрацьовує**       | При кожній зміні значення | Після підтвердження зміни           |\n| **Швидкість реакції**     | Миттєво                   | Після втрати фокусу                 |\n| **Підтримувані елементи** | `&lt;input&gt;`, `&lt;textarea&gt;`   | `&lt;input&gt;`, `&lt;textarea&gt;`, `&lt;select&gt;` |\nВибір події залежить від того, коли потрібна реакція: під час введення (`input`) чи після завершення (`change`).\n&lt;/details&gt;\n&lt;details&gt;\n&lt;summary&gt;119. Чому typeof null повертає об'єкт?&lt;/summary&gt;\ntypeof null\n`typeof null` повертає `\"object\"` через помилку, яка була допущена в перших версіях JavaScript і залишилася зворотно сумісною.\nПояснення:\n**Технічна причина:** У початковій реалізації значення в JavaScript зберігалися як бітові мітки (tags). Значення `null` мітилося як тип об'єкта через бітовий тег `000` (так само, як і об'єкти). Це стало причиною того, що `typeof null` повертає `\"object\"`.\n**Чому не виправили:** Зміна цієї поведінки порушила б зворотну сумісність із величезною кількістю існуючого коду.\nЯк перевірити, чи значення є `null`:\nВикористовуй явну перевірку:\n```javascript\nvalue === null; // Повертає true, якщо value є null\n```\nАльтернативні способи перевірки:\nЧерез `Object.prototype.toString`:\n```javascript\nObject.prototype.toString.call(null); // \"[object Null]\"\n```\nВикористання сучасних утиліт: Лінтери або бібліотеки, такі як Lodash, мають функції для коректної перевірки типів.\nВисновок:\nЦе історичний артефакт мови, і його потрібно враховувати під час написання коду.\n&lt;/details&gt;\n&lt;details&gt;\n&lt;summary&gt;120. Навіщо потрібний конструктор Proxy?&lt;/summary&gt;\nProxy\nКонструктор `Proxy` у JavaScript дозволяє створювати об'єкти, поведінка яких може бути динамічно змінена. Він використовується для перехоплення і налаштування базових операцій над об'єктами, таких як читання, запис, видалення властивостей, виклик функцій тощо.\nЯк працює Proxy:\n**Цільовий об'єкт:** Це об'єкт, над яким виконується операція.\n**Обробник (`handler`):** Об'єкт, який містить функції-пастки (`traps`), що визначають, як виконуються певні операції.\nСинтаксис:\n```javascript\nconst proxy = new Proxy(target, handler);\n```\n`target`: Об'єкт, який буде проксуватися.\n`handler`: Об'єкт з методами (пастками), які перехоплюють операції.\nОсновні пастки:\n`get`: Перехоплює доступ до властивостей.\n```javascript\nconst obj = { name: \"Alice\" };\nconst proxy = new Proxy(obj, {\n  get(target, prop) {\n    return prop in target ? target[prop] : \"Property does not exist\";\n  },\n});\nconsole.log(proxy.name); // Alice\nconsole.log(proxy.age); // Property does not exist\n```\n`set`: Перехоплює запис у властивість.\n```javascript\nconst obj = {};\nconst proxy = new Proxy(obj, {\n  set(target, prop, value) {\n    if (typeof value === \"number\") {\n      target[prop] = value;\n      return true;\n    } else {\n      throw new TypeError(\"Value must be a number\");\n    }\n  },\n});\nproxy.age = 30; // OK\nproxy.age = \"30\"; // TypeError: Value must be a number\n```\n`has`: Перехоплює оператор in.\n```javascript\nconst proxy = new Proxy(\n  {},\n  {\n    has(target, prop) {\n      return prop.startsWith(\"secret\");\n    },\n  }\n);\nconsole.log(\"secretKey\" in proxy); // true\nconsole.log(\"key\" in proxy); // false\n```\n`deleteProperty`: Перехоплює видалення властивості.\n```javascript\nconst obj = { key: \"value\" };\nconst proxy = new Proxy(obj, {\n  deleteProperty(target, prop) {\n    if (prop.startsWith(\"secret\")) {\n      return false; // Забороняє видалення\n    }\n    delete target[prop];\n    return true;\n  },\n});\ndelete proxy.key; // true\ndelete proxy.secretKey; // false\n```\nНавіщо потрібний `Proxy`:\n**_Валідація даних:_** Перевірка при записі чи зчитуванні.\n**_Створення \"захищених\" об'єктів:_** Наприклад, обмеження доступу до певних властивостей.\n**_Логування:_** Відстеження операцій над об'єктом.\n**_Динамічний доступ:_** Зміна поведінки об'єкта залежно від контексту.\n**_Реалізація об'єктів-заглушок:_** Наприклад, для завантаження даних при першому зверненні до властивості.\n`Proxy` — це потужний інструмент для налаштування поведінки об'єктів, що дозволяє створювати адаптивні рішення та вирішувати складні задачі.\n&lt;/details&gt;\n&lt;details&gt;\n&lt;summary&gt;121. Що таке хвостова рекурсія (tail recursion)? Оптимізація рекурсії?&lt;/summary&gt;\nХвостова рекурсія:\nХвостова рекурсія (tail recursion) — це тип рекурсії, де рекурсивний виклик є останньою операцією, що виконується у функції перед її завершенням. Іншими словами, результат рекурсивного виклику безпосередньо повертається, і після цього більше немає інших операцій.\n**Приклад без хвостової рекурсії:**\n```javascript\nfunction factorial(n) {\nif (n === 0) return 1;\nreturn n _ factorial(n - 1); // Результат потребує додаткового множення\n}\n```\n**Приклад з хвостовою рекурсією:**\n```javascript\nfunction factorialTail(n, acc = 1) {\nif (n === 0) return acc;\nreturn factorialTail(n - 1, acc _ n); // Рекурсивний виклик є останньою дією\n}\n```\nОптимізація хвостової рекурсії:\nTail Call Optimization (TCO) — це техніка оптимізації, яка дозволяє мовам програмування ефективно виконувати хвостову рекурсію. Завдяки цьому для кожного рекурсивного виклику не створюється новий запис у стеку викликів. Замість цього, попередній запис замінюється новим.\n**_Як це працює:_**\n  - У звичайній рекурсії кожен виклик створює новий фрейм у стеку, який зберігає інформацію про поточну функцію.\n  - У хвостовій рекурсії з TCO замість створення нового фрейму, існуючий фрейм перезаписується, що знижує використання пам’яті.\n**_Вигоди оптимізації:_**\n  - Зменшення витрат пам’яті.\n  - Уникнення помилок Maximum call stack size exceeded.\n  - Використання рекурсії в обчисленнях без ризику перевантаження стеку.\nПриклад оптимізованої хвостової рекурсії:\n```javascript\nfunction sumTail(n, acc = 0) {\n  if (n === 0) return acc;\n  return sumTail(n - 1, acc + n);\n}\nconsole.log(sumTail(10000)); // Виконання без помилки\n```\nЧи підтримується хвостова оптимізація в JavaScript?\nСтандарт ECMAScript 2015 (ES6) вимагає підтримки TCO, але багато рушіїв JavaScript (наприклад, V8) не реалізують її. Тому, навіть із правильно написаною хвостовою рекурсією, вона може не оптимізуватися.\n**Альтернатива:**\nКоли хвостова оптимізація недоступна, можна використовувати ітеративний підхід або стек вручну:\n```javascript\nfunction factorialIterative(n) {\nlet result = 1;\nwhile (n &gt; 0) {\nresult \\*= n;\nn--;\n}\nreturn result;\n}\n```\nВисновок:\nХвостова рекурсія — це важливий інструмент, але її ефективність у JavaScript залежить від реалізації рушія. Для критичних завдань краще враховувати ітеративні підходи.\n&lt;/details&gt;\n&lt;details&gt;\n&lt;summary&gt;122. Що таке і як працює debounce() та throttle() в JavaScript?&lt;/summary&gt;\ndebounce() та throttle()\n`debounce():`\n`debounce` — це техніка, яка обмежує кількість разів, коли функція викликається. Вона гарантує, що функція виконається лише після певного часу бездіяльності (затримки) після останнього виклику. Використовується для зменшення кількості обробок подій, які відбуваються дуже часто.\n**Як працює:**\nПри кожному виклику функції таймер скидається.\nФункція виконується тільки після завершення затримки.\n**_Приклад:_**\n```javascript\nfunction debounce(func, delay) {\n  let timeout;\n  return function (...args) {\n    clearTimeout(timeout);\n    timeout = setTimeout(() =&gt; func.apply(this, args), delay);\n  };\n}\n// Використання:\nconst onResize = debounce(() =&gt; console.log(\"Resize event!\"), 300);\nwindow.addEventListener(\"resize\", onResize);\n```\n**Коли корисно?:** Виконання запитів на сервер під час введення в полі пошуку, обробка подій `resize` чи `scroll`.\n`throttle()`:\n`throttle` — це техніка, яка обмежує частоту виконання функції. Функція викликається не частіше, ніж раз за визначений інтервал часу, незалежно від кількості викликів.\n**Як працює:**\nПри першому виклику функція виконується одразу.\nПісля цього функція ігнорує виклики до завершення вказаного інтервалу часу.\n**_Приклад:_**\n```javascript\nfunction throttle(func, limit) {\n  let lastCall = 0;\n  return function (...args) {\n    const now = Date.now();\n    if (now - lastCall &gt;= limit) {\n      lastCall = now;\n      func.apply(this, args);\n    }\n  };\n}\n// Використання:\nconst onScroll = throttle(() =&gt; console.log(\"Scroll event!\"), 200);\nwindow.addEventListener(\"scroll\", onScroll);\n```\n**Коли корисно?:** Події `scroll`, `mousemove`, обробка натискання кнопок.\nРізниця між `debounce` і `throttle`:\n| Критерій         | debounce                            | throttle                             |\n| ---------------- | ----------------------------------- | ------------------------------------ |\n| Частота викликів | Лише після завершення затримки.     | Не частіше за встановлений інтервал. |\n| Використання     | Зменшення обробки \"сплесків\" подій. | Регулярне виконання функції.         |\nВисновок:\n`debounce`: Використовуйте, коли потрібен один виклик після завершення серії подій.\n`throttle`: Використовуйте, коли потрібен регулярний контроль виконання функції.\n&lt;/details&gt;\n&lt;details&gt;\n&lt;summary&gt;123. Як у JavaScript працюють декоратори? Як вони можуть бути використані для модифікації поведінки класів та методів?&lt;/summary&gt;\nЯк працюють декоратори в JavaScript:\nДекоратори — це спеціальний синтаксис для модифікації класів або методів. Вони дозволяють додавати чи змінювати функціональність без прямої зміни початкового коду. Декоратори реалізовані у вигляді функцій, які приймають об'єкт або властивість для модифікації.\nСинтаксис:\nДекоратори позначаються символом `@` перед ім'ям функції декоратора.\n```javascript\n@decorator\nclass MyClass {}\n```\n**Важливо:** На момент 2025 року декоратори є частиною пропозиції ECMAScript і можуть потребувати використання транспайлера, такого як Babel або TypeScript.\nВикористання декораторів:\n**_Для класів:_** Декоратор може модифікувати або розширювати функціональність класу.\n```javascript\nfunction addTimestamp(target) {\n  target.prototype.timestamp = new Date();\n}\n@addTimestamp\nclass Example {}\nconst instance = new Example();\nconsole.log(instance.timestamp); // Додає властивість timestamp\n```\n**_Для методів:_** Декоратор може змінити поведінку методу, наприклад, додати логування.\n```javascript\nfunction logMethod(target, propertyKey, descriptor) {\n  const originalMethod = descriptor.value;\n  descriptor.value = function (...args) {\n    console.log(`Calling ${propertyKey} with`, args);\n    return originalMethod.apply(this, args);\n  };\n  return descriptor;\n}\nclass Example {\n  @logMethod\n  sayHello(name) {\n    return `Hello, ${name}`;\n  }\n}\nconst instance = new Example();\nconsole.log(instance.sayHello(\"World\"));\n// Лог:\n// Calling sayHello with [ 'World' ]\n// Hello, World\n```\n**_Для властивостей:_** Декоратор може використовуватися для додавання метаданих або валідації.\n```javascript\nfunction readonly(target, propertyKey, descriptor) {\n  descriptor.writable = false;\n  return descriptor;\n}\nclass Example {\n  @readonly\n  name = \"Fixed Name\";\n}\nconst instance = new Example();\ninstance.name = \"New Name\"; // TypeError: Cannot assign to read-only property\n```\nЯк вони працюють:\n**Класи:** Декоратор приймає сам клас як аргумент і може змінити або повернути новий клас.\n**Методи:** Декоратор приймає три аргументи: `target` (клас), `propertyKey` (ім'я методу), `descriptor` (опис методу), який можна модифікувати.\n**Властивості:** Обмежені лише додаванням метаданих, оскільки властивості ще не створені під час використання декоратора.\nВикористання:\n**Логування:** Відстеження викликів методів.\n**Авторизація:** Перевірка доступу до методів.\n**Кешування:** Збереження результатів виконання функцій.\n**Додавання метаданих:** Наприклад, для ORM або DI-фреймворків (TypeORM, NestJS).\nПриклад із TypeScript:\nTypeScript має вбудовану підтримку декораторів.\n```typescript\nfunction logClass(target: Function) {\n  console.log(`Class created: ${target.name}`);\n}\n@logClass\nclass Example {}\n// Class created: Example\n```\nДекоратори дозволяють модифікувати класи, методи або властивості, роблячи код більш модульним і розширюваним без порушення принципу відкритості/закритості (OCP).\n&lt;/details&gt;\n&lt;details&gt;\n&lt;summary&gt;124. Як можна створити об'єкти з приватними властивостями та методами JavaScript?&lt;/summary&gt;\nМетоди створення об'єктів із приватними властивостями та методами в JavaScript:\n**Використання слабких карт (WeakMap):**\n   - Використовується для створення дійсно приватних властивостей, які недоступні за межами об'єкта.\n```javascript\nconst privateData = new WeakMap();\nclass Example {\n  constructor(value) {\n    privateData.set(this, { secret: value });\n  }\n  getSecret() {\n    return privateData.get(this).secret;\n  }\n}\nconst obj = new Example(\"hidden\");\nconsole.log(obj.getSecret()); // \"hidden\"\nconsole.log(obj.secret); // undefined\n```\n**Використання `#` (приватні поля та методи):**\n   - Приватні поля та методи, позначені символом #, доступні лише всередині класу.\n```javascript\nclass Example {\n  #secret;\n  constructor(value) {\n    this.#secret = value;\n  }\n  getSecret() {\n    return this.#secret;\n  }\n}\nconst obj = new Example(\"hidden\");\nconsole.log(obj.getSecret()); // \"hidden\"\nconsole.log(obj.#secret); // SyntaxError: Private field '#secret' must be declared in an enclosing class\n```\n**Використання замикань:**\n   - Замикання забезпечують приватність через обмежений доступ до внутрішніх змінних функції.\n```javascript\nfunction Example(value) {\n  let secret = value;\n  return {\n    getSecret: function () {\n      return secret;\n    },\n  };\n}\nconst obj = Example(\"hidden\");\nconsole.log(obj.getSecret()); // \"hidden\"\nconsole.log(obj.secret); // undefined\n```\n**Комбінація `Symbol` для унікальності:**\n   - Symbol дозволяє створювати властивості, які не конфліктують із іншими.\n```javascript\nconst secretKey = Symbol(\"secret\");\nclass Example {\n  constructor(value) {\n    this[secretKey] = value;\n  }\n  getSecret() {\n    return this[secretKey];\n  }\n}\nconst obj = new Example(\"hidden\");\nconsole.log(obj.getSecret()); // \"hidden\"\nconsole.log(obj.secretKey); // undefined\n```\nКоли використовувати:\n    - **WeakMap:** Для складних сценаріїв, коли об'єкт потребує багатьох приватних властивостей.\n    - **`#` (Приватні поля):** Простий та сучасний спосіб для класів.\n    - **Замикання:** Для функціональних підходів.\n    - **Symbol:** Для унікальних властивостей із частковою приватністю.\n&lt;/details&gt;\n&lt;details&gt;\n&lt;summary&gt;125. Методи перехоплення та обробки помилок у JavaScript?&lt;/summary&gt;\nМетоди перехоплення та обробки помилок у JavaScript:\n**try...catch**\nОбробляє синхронні помилки у коді. Не працює з асинхронними операціями (наприклад, Promise).\n```javascript\ntry {\n  const result = JSON.parse(\"INVALID_JSON\");\n} catch (error) {\n  console.error(\"Caught error:\", error.message);\n}\n```\n**window.onerror**\nПерехоплює необроблені помилки на рівні глобального об'єкта.\n```javascript\nwindow.onerror = (message, source, lineno, colno, error) =&gt; {\n  console.error(\"Global error:\", message, source, lineno, colno, error);\n};\n```\n**window.addEventListener('error')**\nПерехоплює помилки в зовнішніх ресурсах, таких як зображення або скрипти.\n```javascript\nwindow.addEventListener(\"error\", (event) =&gt; {\n  console.error(\"Resource loading error:\", event.message);\n});\n```\n**window.addEventListener('unhandledrejection')**\nОбробляє необроблені відхилення обіцянок (Promise).\n```javascript\nwindow.addEventListener(\"unhandledrejection\", (event) =&gt; {\n  console.error(\"Unhandled promise rejection:\", event.reason);\n});\n```\n**Асинхронна обробка помилок (async/await):**\nВикористовуйте try...catch для обробки помилок в асинхронному коді.\n```javascript\nasync function fetchData() {\n  try {\n    const response = await fetch(\"https://api.example.com\");\n    const data = await response.json();\n    return data;\n  } catch (error) {\n    console.error(\"Async error:\", error.message);\n  }\n}\n```\n**Обробка помилок у Promises:**\nВикористовуйте .catch для перехоплення помилок.\n```javascript\nfetch(\"https://api.example.com\")\n  .then((response) =&gt; response.json())\n  .catch((error) =&gt; console.error(\"Promise error:\", error.message));\n```\n**Користувацька помилка (Custom Error):**\nСтворюйте власні помилки для специфічних сценаріїв.\n```javascript\nclass CustomError extends Error {\n  constructor(message) {\n    super(message);\n    this.name = \"CustomError\";\n  }\n}\ntry {\n  throw new CustomError(\"Something went wrong\");\n} catch (error) {\n  console.error(error.name + \":\", error.message);\n}\n```\n**Декоратори для обробки помилок:**\nПерехоплюють помилки в методах.\n```javascript\nfunction errorHandler(target, name, descriptor) {\n  const original = descriptor.value;\n  descriptor.value = function (...args) {\n    try {\n      return original.apply(this, args);\n    } catch (error) {\n      console.error(\"Error in method:\", name, error.message);\n    }\n  };\n  return descriptor;\n}\nclass Example {\n  @errorHandler\n  faultyMethod() {\n    throw new Error(\"Oops!\");\n  }\n}\nnew Example().faultyMethod();\n```\n**Сервіси логування:**\nВикористовуйте сторонні сервіси, як-от Sentry або LogRocket, для моніторингу помилок у реальному часі.\n```javascript\nSentry.init({ dsn: \"your-dsn-url\" });\ntry {\n  throw new Error(\"Critical error\");\n} catch (error) {\n  Sentry.captureException(error);\n}\n```\n**Підсумок:**\n  - Обробка помилок у JavaScript охоплює широкий спектр інструментів і технік: від простого try...catch до використання глобальних обробників та спеціалізованих сервісів. Це дозволяє ефективно реагувати на помилки та покращувати надійність додатків.\n&lt;/details&gt;\n&lt;details&gt;\n&lt;summary&gt;126. За який проміжок часу була створена мова програмування JavaScript?&lt;/summary&gt;\nJavaScript\nМова програмування JavaScript була створена за рекордно короткий час — лише **10 днів** у травні 1995 року.\nАвтор мови, **Брендан Айх**, працював тоді в компанії **Netscape** і отримав завдання розробити скриптову мову для браузера **Netscape Navigator**. Спочатку **JavaScript** називався **Mocha**, потім перейменувався в **LiveScript**, а пізніше отримав свою сучасну назву в рамках маркетингової угоди з Sun Microsystems для асоціації з популярною на той час мовою Java.\n&lt;/details&gt;\n&lt;details&gt;\n&lt;summary&gt;127. ???&lt;/summary&gt;\nComing soon...😎\n&lt;/details&gt;\n    &lt;/body&gt;\n  &lt;/html&gt;",
    "codeExample": "const inputField = document.querySelector(\"#myInput\");\n\ninputField.addEventListener(\"input\", (event) =&gt; {\n  console.log(\"Current value:\", event.target.value);\n});",
    "category": "arrays",
    "isFavorite": false
  }
]